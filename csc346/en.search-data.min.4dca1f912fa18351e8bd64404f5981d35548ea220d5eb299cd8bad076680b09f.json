[{"id":0,"href":"/csc346/docs/examples/ajax-demo/","title":"AJAX Example","section":"Examples","content":" AJAX Example # Overview # Here's a walkthrough of a very basic example of a webpage accessing data using JavaScript's XMLHttpRequest object, and the newer fetch API. Through the twists and turns of web standards over the years, this has become the way that JavaScript in a browser can initiate HTTP requests to other resources. This has become known as \u0026quot;AJAX\u0026quot;: Asynchronos JavaScript and XML.\nYou can see this in action by visiting this AJAX Books Example.\nXML? # In the early days of the internet XML was a common, flexible, text-based data interchange format. However it is verbose, and its flexibility leads to it being somewhat difficult to parse. As Javascript became more popular, the object notation it pioneered became used as a data format separate from the language itself. This becane simple \u0026quot;JSON\u0026quot;: JavaScript Object Notation. Without going into the specifics of each format, just know that even though the JavaScript way to make HTTP requests is XMLHttpRequest, it can be used to handle any format of data, and not just XML.\nHTML Page # We'll need a basic HTML page to start with.\n1\u0026lt;!doctype html\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;title\u0026gt;examples/ajax-books.html\u0026lt;/title\u0026gt; 5 \u0026lt;script src=\u0026#34;ajax1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 6 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;ajax.css\u0026#34; /\u0026gt; 7\u0026lt;/head\u0026gt; 8\u0026lt;body\u0026gt; 9 \u0026lt;h1\u0026gt;A Sample AJAX Page\u0026lt;/h1\u0026gt; 10 \u0026lt;section id=\u0026#34;books\u0026#34;\u0026gt; 11 \u0026lt;table id=\u0026#34;book-table\u0026#34;\u0026gt; 12 \u0026lt;tr\u0026gt; 13 \u0026lt;th\u0026gt;Title\u0026lt;/th\u0026gt; 14 \u0026lt;th\u0026gt;Author\u0026lt;/th\u0026gt; 15 \u0026lt;/tr\u0026gt; 16 \u0026lt;/table\u0026gt; 17 18 \u0026lt;button id=\u0026#34;book-button\u0026#34;\u0026gt;Get Books\u0026lt;/button\u0026gt; 19 \u0026lt;/section\u0026gt; 20\u0026lt;/body\u0026gt; 21\u0026lt;/html\u0026gt; This gives us some structure to deal with from the JavaScript side of things. The JavaScript code is loaded on line 5 with the \u0026lt;script\u0026gt; element. This is a relative URL, so the browser requests ajax1.js from the same folder that the .html file is in.\nJavaScript with XMLHttpRequest # We'll go through the contents of ajax1.js in small chunks. You can see the full file here. The code snippets with line numbers below are directly pulled from the JavaScript file. Other code blocks are just additional examples.\n5window.addEventListener(\u0026#39;load\u0026#39;, function() { 6 // Get a reference to our button 7 var button = document.getElementById(\u0026#39;book-button\u0026#39;); 8 button.addEventListener(\u0026#39;click\u0026#39;, getBooks); 9}); This uses the window.addEventListener method to attach a new listener to the load event. Whenever the window's load event completes, the second argument, containing the callback function, will be called. Recall that the basic format for this method is:\nwindow.addEventListener(\u0026#39;eventName\u0026#39;, callbackFunction) In our example, the eventName is \u0026quot;load\u0026quot;, and the callbackFunction is an inline function defined right there:\nfunction() { var button = document.getElementById(\u0026#39;book-button\u0026#39;); button.addEventListener(\u0026#39;click\u0026#39;, getBooks); } This callback function uses document.getElementById to get a reference to the \u0026lt;button id=\u0026quot;book-button\u0026quot;\u0026gt;Get Books\u0026lt;/button\u0026gt; element in our HTML file. Because we added an id attribute to the element's openning tag, it allows us to easily get access to it from JavaScript.\nOnce we have our button element, we'll add an event listener to that element too. In this case we'll listen for the 'click' event, and pass in the getBooks function declaration which is defined next.\n16function getBooks(event) { 17 console.log(\u0026#39;Button Pressed\u0026#39;); 18 19 // Create a new XMLHttpRequest Object 20 var req = new XMLHttpRequest(); 21 22 // Create a callback function when the State of the Connection changes 23 req.onreadystatechange = function() { 24 if (req.readyState == 4) // state of 4 is \u0026#39;done\u0026#39;. The request has completed 25 { 26 loadBooks(req.responseText); // The .responseText property of the request object 27 } else { // contains the Text returned from the request. 28 console.log(req.readyState); 29 } 30 }; 31 32 // Set up our HTTP Request 33 var booksAPI = \u0026#34;https://csc346picturegram.test.apps.uits.arizona.edu/Prod/books\u0026#34;; 34 req.open(\u0026#39;GET\u0026#39;, booksAPI, true); // the 3rd parameter denotes if we want the request to 35 // be asynchronous or not. Here we do, so its true 36 37 // Finally initiate the request 38 req.send(); 39} Here we have some console.log calls to print out progress as we go. This is useful for development and debugging, but remember to take these lines out of production code! For this class, it's fine to leave in any log calls like this.\nNext, we create a new instance of the XMLHttpRequest() class, and store it in our req object.\nWith our new req object, we create a new function expression, and assign it to the .onreadystatechange property of the req object.\nreadystatechange event # https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readystatechange_event The readystatechange event is fired every time the state of the XMLHttpRequest object changes. An HTTP request created and managed by the XMLHttpRequest object goes through various states:\nState Value Description unsent 0 The object has been constructed. opened 1 The open() method has been successfully invoked. During this state request headers can be set using setRequestHeader() and the fetch can be initiated using the send() method. headers received 2 All redirects (if any) have been followed and all headers of a response have been received. loading 3 The response body is being received. done 4 The data transfer has been completed or something went wrong during the transfer (e.g., infinite redirects). It's very rare that we'll actually care about anything other then the done state. So line 24 tests for a value of 4, which is done, and only does something when that's the case. For illustrative purposes though, we'll print out the other states.\nWhat we're basically doing here is saying \u0026quot;when this request has completed, call the loadBooks function, and pass the req.responseText to it\u0026quot; on line 26.\nNote that nothing has actually happened yet. We're still just configuring our req object. Next we have to initialize the request by calling the open method.\nopen # https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open The method name .open is a bit misleading. It does not actually create the socket at this point. It just sets up how and where to connect.\nreq.open(\u0026#39;GET\u0026#39;, booksAPI, true) Similar to other ways we've created HTTP requests, here we specify the HTTP verb, and the URL to access. The third parameter tells the browser to execute this call asynchronously, vs sychronously. Because JavaScript operates on an event loop, it is possible to tell JavaScript to block execution of code until this request completes, or to continue on and let the callback functions handle changes. We almost always want to do things asychronously for a better user experience, even though this makes our job as develoeprs a little harder.\nsend # https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send Finally, we have everything in place to send our request.\nWe've set up where we want to send the request do in the open method, and we've defined how we will handle the reponse with the readystatechange event handler. You can see how this differs from some other programming languages, where we usually assign the result of a request to some variable, such as with the python requests module. A similar API call with python would look something like this:\nbooksResult = requests.get(booksAPI) However with the asychronous JavaScript runtime, instead of blocking execution at the send call, JavaScript immediately returns control to the event loop. The event loop then tracks the progress of the request, and updates the readyState of the req object, calling our registered callback function at each change. When the request completes, and the callback method is finally called with a state value of 4, we know our call has completed (hopefully successfully) and we can access our expected data and do something with it.\nJavascript and the fetch API # While XMLHttpRequest works fine, as you can see, it's a little clunky. As you're probably thinking, this is a bit complicated to explain to new developers. Over the years many libaries attempted to abstract away this complexity: jQuery, Prototype, axios, and others.\nThe web standards community worked on this for some time, and around 2018, the new fetch API became available in browsers. Today all modern browser support this.\nThe fetch API is a Promise based API. This means it avoids the callback nesting problem. It also does a much better job at handling failures. Probably most importantly, it's just simpler to write and read.\nConsider this alternate form of the getBooks() function above:\nfunction getBooks(event) { console.log(\u0026#39;Button Pressed\u0026#39;); fetch(\u0026#34;https://csc346picturegram.test.apps.uits.arizona.edu/Prod/books\u0026#34;) .then((response) =\u0026gt; response.text()) .then((responseText) =\u0026gt; loadBooks(responseText)) } That's it! This acomplishes the same thing as the previous version, but is much more consice and easy to follow. The fetch() function itself has one required argument, the URL to connect with. There's a second optional argument to pass in configuration options. By default the HTTP method will be GET, since that is by far the most used method. If you need to use a different HTTP method, or pass along additional headers, those would all go into the second options argument.\nUpdating the Page # Regardless of which method is used to retrieve data from the API call, we now need to do something with that data.\n"},{"id":1,"href":"/csc346/docs/exams/exam1-guide/","title":"Exam 1 Study Guide","section":"Exams","content":" Exam 1 Study Guide # Cloud Intro - Week 1 Slides # Understand differences and advantages of Datacenters with and without Virtual Machines, and Cloud Computing Review the Job differences between Datacenter and Cloud architectures Basic Linux CLI commands Docker - Week 2 Slides # Docker run, build, images, start, exec commands Docker port mappings Write a basic Dockerfile based on a specification HTTP \u0026amp; HTML - Week 3 Slides # Know the main HTTP methods (GET, POST, etc) Know the basic parts of an HTTP request: Request method \u0026amp; resource, headers, TWO linefeeds Know the anatomy of an HTML element Know the anatomy of a URL Know the basic HTML tags we went over in class Understand how a DOM tree maps to an HTML document Network Sockets - Week 4 Slides # Know the 3 parts of a socket (host IP, port, protocol) Know when BIND, LISTEN, and CONNECT are used in establishing a socket Javascript - Week 5 Slides # Javascript Datatypes Booleans Arrays Functions Objects The document object Event Listeners AJAX/Fetch basics Authentication - Week 6 Slides # Definition of Authentication Definition of Authorization How does HTTP Basic Authentication work? Authorization Header Basic + base64 encoded username:password Passwords should be stored with a strong one-way hash Identity Providers offload user/password security to someone else Facebook GitHub Google etc CAS basics Redirect to IdP Get Ticket back Validate Ticket through backchannel Notes # The following notes page will be attached as part of your exam packet.\nwindow.addEventListener(\u0026#39;eventName\u0026#39;, callback); window.alert(\u0026#39;msg text\u0026#39;); window.close(); window.confirm(\u0026#39;msg text\u0026#39;); element.attributes element.innerHTML element.childNodes element.parentNode element.textContent element.appendChild(newElementObject); element.classList.add(\u0026#34;newClassName\u0026#34;); element.removeChild(elementToRemove); element.addEventListener(\u0026#39;eventName\u0026#39;, callback); console.log(msg); console.trace(); console.warn(msg); document.body document.title document.createElement(\u0026#39;elementType\u0026#39;); document.getElementsByClassName(\u0026#39;className\u0026#39;); document.getElementsByTagName(\u0026#39;tagName\u0026#39;); document.getElementById(\u0026#39;idName\u0026#39;); // The following are command line programs. // The $ represents the prompt, don\u0026#39;t type that. $ nc -v \u0026lt;hostname\u0026gt; \u0026lt;port\u0026gt; $ curl -v \u0026lt;url\u0026gt; $ ls $ cat $ grep $ cd $ less $ rm $ mkdir $ mv $ pwd $ head $ tail $ apt-get update \u0026amp;\u0026amp; apt-get install \u0026lt;package\u0026gt; "},{"id":2,"href":"/csc346/docs/exams/exam2-guide/","title":"Exam 2 Study Guide","section":"Exams","content":" Exam 2 Study Guide # AWS - Week 7 Slides # Know how to get your AWS CLI Credentials Know the difference between a region and and availability zone Know the XaaS basics IaaS - Infrastructure as a Service PaaS - Platform as a Service SaaS - Software as a Service Know the basic AWS Services and what they're used for EC2 RDS Shared Responsibility Model What are you responsible for vs AWS? IAM Roles do what? Define which actors can take which actions on which resources EC2 and RDS - Week 8 Slides # What do you need to know or define when launching an EC2 instance? AMI Image Host OS Architecture Instance Type (ie t2.micro, m5.2xlarge) Security Group Storage SSH Keypair What do Security Groups do? Act like firewalls Allow or Deny network traffic in and out of a resource Understand Stop vs Terminate Understand RDS basics Database Type Instance Type Default Password Storage Security Group JSON and REST - Week 9 Slides # Understand basic JSON format Be able to write some basic JSON JSON can't have comments 😢 JSON is always valid JavaScript but JavaScript is not always valid JSON In JavaScript JSON.stringify() JSON.parse() REST stands for Representational State Transfer REST is not a protocol, it is an architectural style REST Principles Client-Server Architecture Uniform Interface Statelessness Layered System Cacheability Semantic HTTP Methods Infrastructure as Code - Week 10 Slides # Infrastructure as Code Text files Automateable and repeatable processes Know these exist aws-cli CloudFormation AWS SDK (Python boto3) TerraForm Version Control Systems git is the winner GitHub ≠ git Basic git commands git init git add git commit -m \u0026quot;log message\u0026quot; git log "},{"id":3,"href":"/csc346/docs/exams/exam3-guide/","title":"Exam 3 Study Guide","section":"Exams","content":" Exam 3 Study Guide # Managed Cloud Services - Week 11a Slides - Week 11b Slides # Know the basic AWS Services we've used or talked about this semester, and what they're used for. EC2 Virtual Machines Can SSH in You're responsible for OS patching and security RDS Relational Database Platform as a Service ALB Load Balancing SSL/TLS Termination Auto-scaling to handle public load ECS Managed Docker Container Service Run your Docker images in AWS Use with ALB ECR Elastic Container Registry Store your built Docker images in AWS Can pull images from here to run on ECS or EC2 etc. S3 Object storage Not a file system Key/Value Pairs Pay-as-you-go No size limits (no cost limits either!) Lambda Function as a Service Event Driven Pay-as-you-go Simpler than Docker for small / short workloads Cloud Architectures - Week 12 Slides # Architecture Diagrams are Good Consider your audience More detail for technical / coworker audience Less detail for leadersup / supervisor audience CloudFormation Infrastructure as Code Repeatability Input Parameters Codify Resource Deployments Public Key Cryptography - Week 13 Slides # Hashing One Way Math Verify that the input hasn't been altered Hashing the same input always produces the same output Symmetric Cryptography Shared Secret One key is used to both encrypt and decrypt Depends on the key being securely shared Fast Public Key Cryptography Two Keys Public Private Key B decrypts data encoded by Key A Key A decrypts data encoded by Key B One Key kept... private One Key shared publicly Use Case: Privacy Encrypt with a public key - only the private key holder can decrypt Use Case: Authentication Encrypt with private key - decrypting with public key proves where it came from Certificate Authorities Chain of Trust If I trust A, and A says B is trustworthy, I can trust B If I trust B, and B says C is trustworthy, I can trust C OS Vendors certify a set of Root Certificate Authorities Root CAs can delegate to Intermediary CAs Certificates issued by Intermediate CAs can be trusted, because we trust the Root CAs Backbone of internet security Cookies - Week 14 Slides # Cookies preserve state Host controls when and how cookies are set Sent in an HTTP response header: Set-Cookie Browser stores cookies separately for each Domain Cookies are only sent back to the same Domain Basic key/value pairs with some options Used to track state from one request to another by comparing the Cookie value in the HTTP Request with stored information on the Server side First-Party cookies sent by the same Domain as the parent Page Domain Third-Party cookies sent by Domains other than the parent Page Domain Security concerns If attacker can gain access to cookie values, can impersonate users WebSockets - Week 15 Slides # When sateless HTTP doesn't work so well Useful for responsive User Interfaces When anynchronous communication needs to be fast and responsive Polling Useful if the number of clients is small, and polling interval is large WebSockets Better if number of clients is large, and need for client to be notified of new information quickly WebSockets ≠ TCP Sockets Begin live as a normal HTTP request with additional headers: Connection: Upgrade Upgrade: websocket Server responds with: HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= Once the WebSocket upgrade handshake is completed, all furhter communication over that TCP socket no longer follows the HTTP protocol, it follows the WebSockets protocol WebSockets Protocol is Binary, not Text based WebSocket stays open until either side explicitly closes it Data can be sent in either direction. Server no longer has to wait for the client to initiate a request. Host can send to multiple connected WebSockets AWS API Gateway Cloud Managed WebSocket endpoint Computes handshake and keeps track of connections Sends events to other AWS services, such as Lambda Use the AWS API to have API Gateway send data to clients over connected WebSockets JavaScript API const exampleSocket = new WebSocket(\u0026quot;wss://example.com/api\u0026quot;) ws://: Start a WebSocket over a non-secured HTTP connection wss://: Start a WebSocket over a TLS secured HTTPS connection Send data: exampleSocket.send(data) Receive data: exampleSocket.addEventListener(\u0026quot;message\u0026quot;, (e) =\u0026gt; {processEvent(e)} ) "},{"id":4,"href":"/csc346/docs/exams/notes/","title":"Exam Notes","section":"Exams","content":" window.addEventListener(\u0026#39;eventName\u0026#39;, callback); window.alert(\u0026#39;msg text\u0026#39;); window.close(); window.confirm(\u0026#39;msg text\u0026#39;); element.attributes element.innerHTML element.parentNode element.style.propertyname = \u0026#34;newCSSvalue\u0026#34;; element.textContent element.appendChild(newElementObject); element.classList.add(\u0026#34;newClassName\u0026#34;); element.removeChild(elementToRemove); string.toUpperCase(); string.toLowerCase(); console.log(msg); console.trace(); console.warn(msg); document.body document.title document.createElement(\u0026#39;elementType\u0026#39;); document.getElementsByClassName(\u0026#39;className\u0026#39;); document.getElementsByTagName(\u0026#39;tagName\u0026#39;); document.getElementById(\u0026#39;idName\u0026#39;); // Notes Page myArray = [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;]; Problem 10 - Option B should read: \u0026quot;I have your Private Key, and you have your corresponding Public Key.\u0026quot;\n"},{"id":5,"href":"/csc346/docs/homework/hw01/","title":"Homework 1","section":"Homework","content":" CSC 346 - Spring 2024 - Homework 1 # Most homeworks will be mini-projects, with some homeworks building on one another. This first homework will be a bit simpler though. I will provide solutions to each homework, so if you get stuck on one part it shouldn't impact the later parts too much.\nPoints # This assignment will be worth 16 points (two points per part). Turning the assignment in early will earn you an additional 2 points extra credit.\nEarly submission: January 25th 11pm MST (UTC-7) Final Due Date: January 27th 11pm MST (UTC-7) Starting Point # For each homework assignment I will provide a starter .zip file. The starter zip for this assignment contains a text file which you will fill in with answers for parts of the assignment.\nhttps://www2.cs.arizona.edu/classes/cs346/spring24/homework/NETID-hw01.zip What to turn in # Each homework assignment will be submitted as a single .zip file. Rename the starter zip you download for this assignment with your netid in place of NETID. So if I was turning in this assignment I would rename the folder to fischerm-hw01 and then zip it up and submit fischerm-hw01.zip to D2L.\nTurn in a .zip file of a folder containing the following files:\nNETID-hw01/ docker-screenshot.png (or .jpg) hw01-answers.txt Double Check! Not sure if your .zip file is correct? Try expanding it and see what's actually inside before you turn it in. Part 1: Docker # Much of the work for this class will be done within a Docker environment to have a uniform development environment across the wide variety of computers everyone in the class has access to.\nInstall Docker # A small number of you may already have Docker installed; if you'd like, try typing docker in your shell. If you get a big help output, great, you don't have to install Docker! But most of you will get a \u0026quot;command not found\u0026quot; sort of error.\nPlease install Docker Desktop. It is available, entirely free of charge, at\nhttps://www.docker.com/products/docker-desktop/ After it installs, it will take a few minutes for the \u0026quot;Engine\u0026quot; to start; once it does, you should see a window that looks roughly like this:\nCommand Line Interface \u0026amp; Shell # To run docker, you will need a shell, where you can type the commands. Again for consistency sake, I recommend installing VS Code. It is not required if you already have a development workflow that works for you. However it will be the tool that I will be most able to assist with.\nhttps://code.visualstudio.com/Download If you have installed VS Code you can use the built-in terminal (View -\u0026gt; Terminal, or ctrl-~) If you are on Mac, you can open the Terminal application at /Applications/Utilities/Terminal.app If you're on Linux, then bring up any Terminal or Commaand Prompt. If you're on Windows, depending on your OS version, you may have the new Windows Terminal experience, or the original CMD and PowerShell Prompts. Run Container # It's quite easy to run a container! Just go to your shell, and type the following command:\n$ docker run -it python:3.10 bash You should see Docker download a few images, and then it will start up a new container, using the python image for version 3.10. You will see that you're inside the container because the prompt changes, like this:\n$ docker run -it python:3.10 bash Unable to find image python:3.10 locally latest: Pulling from library/python:3.10 16ec32c2132b: Pull complete Digest: sha256:82becede498899ec668628e7cb0ad87b6e1c371cb8a1e597d83a47fac21d6af3 Status: Downloaded newer image for python:3.10 root@89908dbc0af1:/# You should see a blinking cursor on the last line, indicating that you are currently in an interactive shell within the container. The command line prompt root@7af0c2e2c7c5:/# tells you that you are the root user inside the container with an ID of 7af0c2e2c7c5.\nWhat to turn in # Take a screenshot of your terminal window with the output of your docker run command. Name it \u0026quot;docker-screenshot\u0026quot; with whatever image extention it is, and put it into your folder to zip and turn in.\nPart 2: Exploring # Answer some basic questions about the container that you are in. (You're still inside the python container, right?) Turn in the answers to these questions:\nWhere are you? # When the container first starts, what directory are you in? What command could you use to find this?\nWhat's in the directory you are in? # Use ls or ls -lh to get a list of all of the things in the directory. Copy the list into your solutions file. (You don't need to know what any of these are, yet.)\nWhat are in some other directories? # How do you move into another directory? Look for the /usr directory. List everything that is in that directory as well. Copy both the command you used and its output to your solutions file.\nPart 3: Creating a File # Most Docker images we'll work with don't have any command line text editors such as 'vim' or 'emacs' installed. So we'll use the 'echo' command to create some basic files.\nBefore you make these files, go to your home directory. Remember how to do that? Once you're in your home directory, create a new text file with \u0026quot;Hello world\u0026quot; in it.\n$ echo Hello world \u0026gt; hello.txt Use ls to see how the directory has changed, and cat to read the contents of the file. Put your results into your solutions file.\nPart 4: Moving and Copying # Rename your file from hello.txt to hello-world.txt Use ls to confirm that the name has changed. Use cat on the new filename, and also on the old filename. Put your results into your solutions file.\nThen, duplicate the file several times. Can you put a duplicate file (with a different name) into the current directory? Can you put on into a different directory? Once you've figured out how, record the commands that you used into your solutions file.\nPart 5: Directories # Create a new directory in your home directory, cd into it, and create three small files, all different. Use ls -al to show them. Which column in the output is the size of the file, do you think? Put your results into your solutions file.\nAttempt to remove the directory that you just created. What is the error? Work around the error, and put your observations into the solutions file.\nPart 6: Grep and Pipes # The grep program can be used to search for text in files and from STDIN. First let's look at a file. From anywhere in your container, use the following command to search through a log file:\ngrep group /var/log/alternatives.log What does the output of this command look like? Compare this to the full text of the file.\ngrep can be used on files, like you've done so far - but it can also read from its own stdin. To make it read from stdin, all you have to do is, not give it a file to search!\nGo back to the log file we were looking at before (/var/log/alternatives.log) and chain together two grep commands: the first should search for install; pipe it into a second, which searches for quiet. Which lines get printed?\nI often find it easier to remember only one form for grep, so sometimes I will just do a simple cat as the first command, and pipe it into a grep. Try out that version as well.\nPut your results into your solutions file.\nPart 7: Multiple containers # Open up multiple shells on your computer. If you're using VS Code, slect Terminal \u0026gt; New Terminal from the menus. This should open a new tab with an additional shell prompt. Inside each one, start a python:3.10 container. Then make some file modifications in one of the containers. Check: do see the same changes in the other container, or not? What does this tell you about running multiple containers at the same time?\nPart 8: Cleaning Up # When you are done with your container, you need to clean it up. We don't need to save anything that changed inside the container this time, so don't worry about that.\nAssuming that your original container is still running, it's time to stop it! The \u0026quot;cleanest\u0026quot; way to do this is to close it down from inside. Try typing exit on the command line, inside your shell, or holding down the ctrl key and the D key (ctrl-d).\nThe shell program inside your container should terminate; when it does, the container itself will stop (because the process that was used to create it has exited).\nDocker should return you to the command line of your own computer. Once it does, re-check the status of all containers with docker ps and docker ps -a . Put your results into your solutions file.\nIf any containers are still running, you can stop them using the docker stop [container id] command.\nYou can remove a stopped container with the docker rm [container id] command.\nDocker images can take up a fair amount of space on your host. Use docker images to show the images you have downloaded and add that to your solutions file.\nTo remove an image from your computer (remember you can always download it again) use docker rmi [image id].\nIf you're done with everything and you just want to clean up everything, you can use docker system prune -a. Remember this will delete any data stored in stoped containers and any images you've saved!\n"},{"id":6,"href":"/csc346/docs/homework/hw02/","title":"Homework 2","section":"Homework","content":" Homework 2 # In this assignment you will create a Dockerfile and image which will serve up a simple website.\nPoints # This assignment will be worth 50 points. Turning the assignment in early will earn you an additional 4 points extra credit.\nEarly submission: February 1st 11pm MST (UTC-7) Final Due Date: February 3rd 11pm MST (UTC-7) Starting Point # For each homework assignment I will provide a starter .zip file. The starter zip for this assignment contains an empty Dockerfile you will fill out with commands to build an image.\nhttps://www2.cs.arizona.edu/classes/cs346/spring24/homework/NETID-hw02.zip Part 1 - Dockerfile # nginx # There are many web server applications out there: Apache httpd, nginx, Microsoft IIS, and more.\nWe'll use the nginx web server for our first image that we build. It is lightweight, fast, and focused on the core jobs of a HTTP server.\nThere is an official httpd image maintained by the nginx project.\nThere is an official nginx image maintained on Docker Hub. https://hub.docker.com/_/nginx You will use two different versions of this image for this problem. For the development phase, use the 1.25 version of the image. Once you get everything working and are satisfied, switch to the 1.25-alpine version.\nWhy nginx:1.25 and not nginx:latest? You can never tell when software projects are going to update things. Who knows when 1.26 will be released. Maybe something will change in a newer version that makes some of these homework instructions not quite work right. It's pretty unlikely that a project will update things in a breaking way in the 2 weeks or so a homework assignment is out there, but you never know! This should help introduce you to the idea of pinning your depencencies to a known good version. This allows you the flexibility (but also the responsibility) to update things on your schedule, and not someone elses'. About Alpine # https://alpinelinux.org/about/ Alpine linux is an extremely small and minimal distribution of the linux operating system. Docker images based on alpine are typically an order of magnitude smaller than their corresponding 'full' images. For example, the nginx:1.25 image is about 135MB in size, while the nginx:1.25-alpine image is only 43MB. Other images are even more dramatic, the python:3.10 image we've been using so far weighs in at 1.01GB, while the python:3.10-alpine image is only 55.1MB!\nSo why don't we use alpine all the time? Well quite frankly there's nothing in them, that's why they're so small. There's no bash shell, you have to use the very minimal sh shell. There are no manual pages for anything, and the man command does not exist. There's no ssh, no vim, and no other common system languages such as perl. Additionally the commands it does support, like the basics of ls, cd, grep, etc are all actually aliases to the busybox program. Busybox aims to recreate most of the common functionality of many commands, but with a focus on size and efficiency. So it won't have all the options available and may behave differently than the 'real' versions of these commands. However the busybox binary is only 873K, which is smaller than the full versions of ls (140K), cp (136K), grep (175K), mv (132K), and tar (524K) combined, yet provides dozens more commands.\nRemember when I mentioned that speed of deployment makes a difference? Being able to deploy a 50-60MB image takes much less time than deploying a nearly 1GB image.\nHowever, due to the limitations in alpine, I definitely do not recommend starting there. Get everything working first, and then switch to alpine for final testing, and submit that version of the Dockerfile.\nStart Simple and Iterate # Start with a very basic Dockerfile. You can have just a single line in there to start with, and then build the image from that and try to run it. Yours should behave exactly like the default nginx:1.25 image at this point.\nWhat is the most basic Dockerfile you can make?\nCan you perform a very basic docker build ... command succesfully?\nAs you make progress with various steps, you can update your Dockerfile, re-build your image, and run a new container from the updated image.\nPort Mappings # In order for you to see the web page the container will serve up from your host's browser, you must expose ports from inside the container. You do this with the -p option to the docker run command. Read up on the syntax of port mapping at the Docker documentation site.\nThe httpd server runs on port 80 by default inside the container, and you will need to map that to port 8080 on your host. You should be able to view the default web page by going to http://localhost:8080/ in your browser.\nWebsite # Rather than simply serving up a default web page, I have prepared a very basic website for you to use instead. It is located here:\nhttps://www2.cs.arizona.edu/classes/cs346/spring24/homework/hw02-files.tar You will need to download this file into your container during the build process, 'un-tar' it, and replace the default webpage that comes with nginx. To download the file, I would recommend using the curl command that is available with the nginx image.\nImportant It's fine to download this .tar file to your workstation and play around with it during development, but it won't be part of your assignment submission. Commands to download this file and set it up in the image must all be part of your Dockerfile. Once you have downloaded the .tar file, you will need to un-tar it, then move the files from the hw02-files directory that was unzipped and replace the default files. If you haven't used the tar command before, the basics of the command are:\n$ tar [options] [filename.tar] $ tar -xf hw02-files.tar The -xf options tells the tar command to \u0026quot;eXtract\u0026quot; an archive, and that the source to extract is coming from a \u0026quot;File\u0026quot; and not STDIN.\nMove the files from the expanded folder into the default website location within the container. See the next section for hints on where that might be.\nWhen you get everything working, you should be able to see the following in your browser when running your container and visiting http://localhost:8080/.\nModify nginx default config # Lastly we want to change some of the default configuration of the nginx web server. To do this, we must first get a copy of the default default.conf file out of the container. Refer to the lectures slides for ways we discussed on getting things out of a container.\nThe configuration file is located at /etc/nginx/conf.d/default.conf inside the container. When you get the file, place it in your working directory on your host, in the same folder your Dockerfile is in.\nOpen default.conf in your editor of choice, and look for the error_page directive. Un-comment this line be removing the leading # character, and save the file.\nOfficial nginx documentation\nhttps://nginx.org/en/docs/ Update your Dockerfile to put your version of default.conf into the container, overwriting the one from the base image.\nPerform a new build, and run your container to test your configuration change. If you visit a page that doesn't exist, such as http://localhost:8080/lightsabers you should see a version of the 404 error page that has \u0026quot;CSC 346 Spring 2024\u0026quot; in the footer instead of the default \u0026quot;nginx 1.25\u0026quot;. If you see that version of the error page then you've got it correct!\nWhere should the website files go? # Poke around! Use your unix command line tools to look at where you are when you enter the container. What files and folders are here? Do you see anything that look like web pages? Look through the default.conf configuration file. Is there anything in there that hints at where web pages are stored?\nWhat to turn in # You should turn in a zip file of a folder containing two files: your Dockerfile and your modified default.conf\nyournetid-hw02/ Dockerfile default.conf Zip up the whole folder, not just the two files inside it. Turn in the zip file to D2L.\nDon't forget to switch your base image to nginx:1.25-alpine and test that before turning in. Double Check! Not sure if your .zip file is correct? Try expanding it and see what's actually inside before you turn it in. Debugging Errors # Getting unable to connect errors in your browser when trying to access your container? # Here are a couple ideas on how to troubleshoot.\nGo back a step. Rather than running your image, can you get the nginx:1.25 image to work? Maybe the problem is not with your image, but how you're running it. Is nginx running inside your container? What unix command could you use to find this out? When you issued your docker run command, what command did you tell the container to execute? If you are in a bash shell, does that override the default image CMD? Can you start nginx manually from within the container? What is the default CMD that the nginx:1.25 image has set? How could you find that out? (hint, look at Docker Hub: https://hub.docker.com/_/nginx and find the Dockerfile for 1.25) Did you get your port mappings correct? You should be using 8080 for your host port, and 80 for your container port. What URL are you going to in your browser to test? Did you run nginx but now can't get out of it? # Most running unix programs can be quit by holding down the control key along with the c key. You may see this abbreviated as ^c or sometimes just referred to as 'cancel'.\nThe nginx container runs but I still only see the default site. # Make sure you are putting the new website files into the correct location inside the container. Connect to the running container with a new bash shell and explore the file system. Where did your files actually end up?\nGetting a caught SIGWINCH, shutting down gracefully error when running your container? # Sometimes resizing your terminal window after running the container results in these errors. Use ctrl-c to cancel your running container and re-start it.\nSo far in class we've only run containers with the -it options. This runs the container in an interactive mode and connects the terminal. However the nginx program doesn't like the -t option if you run it directly from docker run instead of manually from a shell inside the container. Try removing the -t option and running it again. You'll have to remember to replace it if you need to poke around inside your container again, or you could have nginx running in one terminal, and then use docker exec to connect a second terminal to the running container, and poke around there.\nYou can also explore the -d option instead of -it. This runs the container in detached mode. It will just print the container ID and return you to your terminal. This is how most services are run in production, where you just want the main program (httpd in our case) to run continually.\nHow do you exit a detached container? Look at the documentation for docker stop.\n"},{"id":7,"href":"/csc346/docs/homework/hw03/","title":"Homework 3","section":"Homework","content":" CSC 346 - Homework 3 # In this homework assignment we'll be working with the HTTP protocol, and writing our own HTML web pages. You will turn in a .zip file of a folder containing the following files:\nWhat to turn in # yournetid-hw03/ Dockerfile html/ index.html http.html images/ ua-logo.png You don't have to turn in the contents of the scripts folder that comes in the starter zip, but it's fine if you do.\nDouble Check! Not sure if your .zip file is correct? Try expanding it and see what's actually inside before you turn it in. Points # This assignment will be worth 50 points. Turning the assignment in early will earn you an additional 3 points extra credit.\nEarly submission: February 8th 11pm MST (UTC-7) Final Due Date: February 10th 11pm MST (UTC-7) Getting Started # The starter zip for this assignment contains an empty Dockerfile you will fill out with commands to build an image, as well as an empty html folder, and some .sh and .ps1 scripts to assist with building your image and running your container. You don't have to use these scripts, but they might help.\nhttps://www2.cs.arizona.edu/classes/cs346/spring24/homework/NETID-hw03.zip Inside of the html folder, create one last folder named images. This is where you will put the University of Arizona logo after you download it.\nPart 1 - Dockerfile # In order to view our webpage, we will include it in a docker container running the nginx web server.\nIf you want the convenience of not having to rebuild your docker image each time you change your web page, remember that you can mount in a folder from your working directory in the docker run command:\ndocker run -i --rm --name hw -p 8080:80 \\ -v \u0026#34;$PWD/html:/usr/share/nginx/html/\u0026#34; nginx:1.25 See scripts/dev.* for helper scripts.\nYou can now open your page in a browser by visiting http://localhost:8080/.\nThis lets you edit and save your HTML pages, and just hit reload in your browser window, speeding up your development process.\nOnce you are comfortable that you have your HTML files correct, you will need to update the starter Dockerfile to COPY the contents of the html folder from your project directory inside the container in the correct location, so that when the container is run, your new site will be displayed.\nYou can then build and run your container with the following commands:\ndocker build --tag hw:latest . docker run -i --rm --name hw -p 8080:80 hw:latest See scripts/build.* and scripts/run.* for helper scripts.\nNot seeing what you expect? Seeing the default nginx page or maybe the page from Homework 2? Web browsers cache contents, and may not have actually reloaded your location. Check the Troubleshooting section below. Part 2 - index.html # Create a new text file inside of the html folder called index.html. The names of these files is significant. The web server looks for .html files inside of its location root directory to serve up as html content. Additionally the special name of index.html means that the web server will return this page when just the directory containing that index is requested, ie the following two requests will result in the same page being returned.\nGET /homework/ HTTP/1.1 GET /homework/index.html HTTP/1.1 Note: this is a feature of the web server, not the HTTP protocol. See the location section of the default.conf file for nginx from homework 2.\nlocation / { root /usr/share/nginx/html; index index.html index.htm; } index.html contents # Your index.html page must contain the following:\nThe !doctype html element head element title element with contents of \u0026quot;Homework 3\u0026quot; body element h1 header element with contents of \u0026quot;CSC 346 Homework 3\u0026quot; h2 header element with contents of \u0026quot;Image\u0026quot; p element with an img element inside it, with the ua-logo.png image as its source. You can download the ua-logo.png from this link. The img tag should have the alt attribute set inside of it to \u0026quot;The official 'Block A' logo for the University of Arizona.\u0026quot; h2 header element with contents of \u0026quot;Paragraph\u0026quot; p element with contents of \u0026quot;Here is some text inside of a paragraph element.\u0026quot; h2 header element with contents of \u0026quot;Unordered List of Droids\u0026quot; ul unordered list containing 4 list items (li elements): R2-D2, C3P0, D-0, BB-8. h2 header element with contents of \u0026quot;Table\u0026quot; table with 2 columns, table headers, and 2 data rows: Column headers of \u0026quot;tag\u0026quot; and \u0026quot;description\u0026quot; Two rows describing the following basic HTML elements, with the name of the tag in the first column, and the description in the second. \u0026lt;ol\u0026gt;: An ordered list tag \u0026lt;img\u0026gt;: An image tag h2 header element with contents of \u0026quot;Link\u0026quot; p element with the text \u0026quot;This is a link to an HTTP example.\u0026quot; and have that text be a clickable a element that goes to a second page named http.html. When finished, your page should look pretty close to the following:\nWait! How do we show HTML elements in an HTML page? You have to use HTML entity encoding. https://developer.mozilla.org/en-US/docs/Glossary/Entity Part 3 - http.html # For our second web page, we want to have it show the output of a nc call that you make in a terminal window. Similar to the first assignment, where you ran commands in the terminal and copy/pasted the results in to a text file. This time you'll copy and paste the results into an HTML file.\nhttp.html contents # Create a new text file inside your html folder, and name it http.html. Similar to the index page, this new page needs to have html, head, title, and body elemetnts. Inside the body element for this page place the following:\ntitle element should have the contents \u0026quot;Homework 3 HTTP Example\u0026quot; h1 element with contents of \u0026quot;CSC 346 Homework 3 HTTP Example\u0026quot; p element containing a pre element Inside the p \u0026gt; pre element, show a full HTTP/1.1 request that GETs a sample page from the course website: https://www2.cs.arizona.edu/classes/cs346/spring24/homework/hw03-http-get.html Include ONLY the response code and response headers. Not the HTML text from the response body. p element with the text \u0026quot;Home\u0026quot; which is an a anchor tag that takes us back to index.html. If your laptop doesn't have the nc command, SSH to lectura.cs.arizona.edu and run it from there.\nfischerm@lectura:~$ nc -v www2.cs.arizona.edu 80 www2.cs.arizona.edu has a relatively short timeout period. Unlike example.com, if you don't send a valid HTTP request within about 10 seconds, you'll either get a HTTP/1.1 408 Request Time-out error, or the connection will just close. Try typing your request in a separate text document and then pasting it into your nc socket. Don't forget the two CRLF sequences required to end the HTTP request! Troubleshooting # Check Cacheing # Modern web browsers will cache many of the resources we request: HTML pages, CSS files, Javascript files, images, etc. This is great for performance and speed, but drives us crazy as developers. If you find yourself making changes and not having them show up when you reload the browser, it might be a cacheing issue.\nFirefox: Disable Cacheing # If you're using the Firefox web browser, you can disable cacheing when the developer tools are open.\nFrom the Tools menu, go to the Browser Tools submenu, and select \u0026quot;Web Developer Tools\u0026quot;. Or, right-click anywhere on the page and select \u0026quot;Inspect\u0026quot; from the context menu. From the developer tools that opens in the lower part of the window, select the \u0026quot;Network\u0026quot; tab. In the toolbar just below the tabs, check the \u0026quot;Disable Cache\u0026quot; checkbox. Firefox will remember this checkbox from session to session, but it will only function if the Web Developer Tools panel is open.\nShift-Reload # Most browsers will treat a \u0026quot;Shift-Reaload\u0026quot; action as instructiong the browser to not use the cache for the next set of requests and instead download all the resources again. Different browsers do this differently. Some work with Shift-Ctrl-R but others only work if you hold down the Shift key while clicking the reload button in a toolbar.\nReload a bunch # Sometimes if you just mash the reload button several times, the browser gets the hint and actually reloads the page.\nFlush Caches # All browsers have a way to flush the cache. However this can sometimes flush all of the cached data in your browser, including 'remembered' logins to other websites.\nPrivate Window / Incognito Window # Opening a new private window will effectively start with an empty cache. This is sometimes the best way to make sure you're \u0026quot;starting fresh\u0026quot; with a website or HTTP request.\n"},{"id":8,"href":"/csc346/docs/homework/hw04/","title":"Homework 4","section":"Homework","content":" CSC 346 - Homework 4 # In this homework assignment we'll begin working with the JavaScript programming language. You will turn in a .zip file of a folder containing the following files:\nWhat to turn in # yournetid-hw04/ Dockerfile html/ index.html js/ hw04.js Points # This assignment will be worth 50 points. Turning the assignment in early will earn you an additional 5 points extra credit.\nEarly submission: February 15th 11pm MST (UTC-7) Final Due Date: February 17th 11pm MST (UTC-7) Getting Started # You will need to create one web page, one JavaScript file, and a Dockerfile defining an image that will serve up your simple website.\nThe starter .zip for this assignment contains the basic directory structure, a starter Dockerfile, HTML file for Part 1, and a javascript file for the remaining parts.\nhttps://www2.cs.arizona.edu/classes/cs346/spring24/homework/NETID-hw04.zip Dockerfile # In order to view our webpage, we will include it in a docker container running the nginx web server. If you've set up your homework project folder as described above, the following Dockerfile should get your html files into the container.\nFROM nginx:1.25 COPY ./html /usr/share/nginx/html/ You can then build your container with the following command:\n$ docker build -t hw04:latest . If you want the convenience of not having to rebuild your docker image each time you change your web page, remember that you can mount in a folder from your working directory in the docker run command:\n$ docker run -i --rm --name hw04container -p 8080:80 \\ -v \u0026#34;$PWD/html:/usr/share/nginx/html/\u0026#34; hw04:latest You can now open your page in a browser by visiting http://localhost:8080/.\nThis lets you edit and save your files, and just hit reload in your browser window, speeding up your development process.\nNot seeing what you expect? Double check that you are in the correct homework folder, and that the tag of the image you built is the same one that you are running. Part 1 # First we need to include the javascript code in your HTML page. To do this you will need to add a \u0026lt;script\u0026gt; element to your HTML page which tells the browser how and were to load your javascript code file from. See slide 50 from the Javascript slides.\nWhen finished, your page should look pretty close to the following. If you don't see the \u0026quot;Javascript file loaded!\u0026quot; text under Part 1, you're not loading your javascript file quite right yet.\nPart 2 # This will mostly just demonstrate how to think about solving the remaining problems. We want to display a message inside of the part2answer span when the button is clicked, similar to what is happening in Part 1. The contents of the span should be a string with the following format:\nelementName clicked. x(Xcoord) y(Ycoord)\nThese values will come from the event object which is passed when you receive a click event.\nFirst, we will need to define a function which will be called when our button is clicked. This will be a normal function declaration:\nfunction runPart2(event) { var answerElement = document.getElementById(\u0026#34;part2answer\u0026#34;) answerText = `${event.target.id} clicked. x(${event.x}) y(${event.y})` answerElement.textContent = answerText } We start off with the function declaration signature, expecting an event argument to be passed to our function. Next we will need to get a reference to our answer span, so we can update its text content with our answer. This is done with the document.getElementById method, and this is why we made sure to have id attributes on all of our important HTML elements. Having unique ids makes getting references to them with JavaScript very straightforward.\nThen we assemble a string containing our answer text, and assign it to the answerText variable. Here we used the backtick character to surround our string, which lets us use JavaScript's Template Literals feature. This allows for direct variable interpolation inside of the string using the ${expression} syntax. This allows for much cleaner strings when you need to have the values of variables included. Compare this to standard string concatenation:\n// The following two statements are equivalent answerText = `${event.target.id} clicked. x(${event.x}) y(${event.y})` answerText = event.target.id + \u0026#34; clicked. x(\u0026#34; + event.x + \u0026#34;) y(\u0026#34; + event.y + \u0026#34;)\u0026#34; Finally, we assign our answerText content to the answerElement.textContent property. This updates the page with our value.\nSo far we have a function which will update an element on the page when it is called, but nothing is calling it yet.\nWe want our function to be called when we click on the \u0026quot;Run part 2\u0026quot; button. To do this, we need to attach a new event listener to that button:\npart2 = document.getElementById(\u0026#34;part2button\u0026#34;) part2.addEventListener(\u0026#34;click\u0026#34;, runPart2) Here again we need to first get a reference to the right button using document.getElementById. Then we register our runPart2 function as a new event listener for the \u0026quot;click\u0026quot; event.\nAt this point, your hw04.js file should look like this for Part 2:\nfunction runPart2(event) { var answerElement = document.getElementById(\u0026#34;part2answer\u0026#34;) answerText = `${event.target.id} clicked. x(${event.x}) y(${event.y})` answerElement.textContent = answerText } part2 = document.getElementById(\u0026#34;part2button\u0026#34;) part2.addEventListener(\u0026#34;click\u0026#34;, runPart2) Now you should be able to load up http://localhost:8080/ in your browser (after running your docker container) and click on the Run part 2 button to see our code executed, and the page update.\nPart 3 # For part 3, we want to get introduced to the JavaScript Date object. For this problem, you will need to create a new Date object for the current date and time and assign it to a variable. You then need to call your object's toDateString() method, and store the output of that in an answerText variable. Lastly you need to update the part3answer span element with the answerText.\nHere's a skeleton of code for this to get you started:\nfunction runPart3(event) { // Create a new Date object and store it in a new variable. // Call the toDateString() method on your variable, and store // the result in a new variable named answerText. // Obtain a reference to the part3answer element and // store it in a variable named answerElement. // Assign the answerText to the answerElement\u0026#39;s textContent property. answerElement.textContent = answerText } // Obtain a reference to the part3button element, and store it // in a variable named part3 part3 = document.getElementById(\u0026#34;part3button\u0026#34;) // Attach an event listener to the part3 element\u0026#39;s click event // and pass it our runPart3 function. part3.addEventListener(\u0026#34;click\u0026#34;, runPart3) Part 4 # For Part 4, we want to convert a string of comma (,) separated values into an array. Here we will take the input from an input element on our page. For example if we type in one,two,three into the input field and click the Run part 4 button, it should output [\u0026quot;one\u0026quot;,\u0026quot;two\u0026quot;,\u0026quot;three\u0026quot;]. Recall from class that we can use the split() method of the String object to do this.\nPart 5 # For Part 5, we will compute some values of the famous Fibonacci sequence. Recall that the Fibonacci sequence requires to initial conditions, and then the next value is computed by adding the current value and the previous value. For this, you will need to create your own Fibonacci Class.\nWe'll use the newer Class syntax to define our Fibonacci class. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes for more information.\nTo start off our Fibonacci calculations, we'll need two values. We will get these from a comma separated pair from the part5input element. For exmaple if we type in \u0026quot;0,1\u0026quot; into that field, we'll get the classic Fibonacci sequence. We will print out the initial values, and then the next 10 values in the sequence, for a total of 10 values. Remember that our input will be Strings, and if you \u0026quot;add\u0026quot; strings together it's just string concatenation. For example \u0026quot;1\u0026quot; + \u0026quot;1\u0026quot; reults in \u0026quot;11\u0026quot;, which is not what we want. You will need to convert these to a Number.\nPart 6 # For the last part, we'll make an API call to the healthcheck method of a PictureGram API. This method just replies with a basic \u0026quot;OK\u0026quot; status, and echos back details of the request itself.\nWe'll need a separate function to be executed once the API call completes. This function will update the web page with the results of the API call. Since we made the part6answer element a \u0026lt;pre\u0026gt; element, it will be nicely formatted for the JSON data we'll get.\nFor our runPart6 function, we need to make an HTTP call using the Fetch API. I mean if you want to do it with XmlHttpRequest you can, bit wouldn't recommend it 😆.\nThe healthcheck method of the API will echo back any query string arguments that are passed long. We'll just pass one along with our API request, called \u0026quot;parameter\u0026quot;, and use the value from part6input. Query string arguments are appended to the end of a URL after a question mark, and are key=value pairs. If we put \u0026quot;apple\u0026quot; into the input field, then the API call we would make would be:\nhttps://csc346picturegram.test.apps.uits.arizona.edu/healthcheck?parameter=apple You can test this particular API out in a regular web browser. If you put that URL in to a browser and visit it, you can see what the response will be.\nNote! The fetch() API will throw all sorts of CORS errors if you try and run your file by simply loading it in the browser from your local file system. i.e. if you did an \u0026quot;Open File...\u0026quot; from your browser and just open up your index.html that way. The security model of browser won't let the network request be accessible to your JavaScript code.\nBe sure to run your container, and access your file through http://localhost:8080/.\nFor a more throughough walkthroug and explanation of the fetch API, see the AJAX Example under the Examples section of this site.\nFinal Results # Your final result should look something similar to this. Things like the date will be different, and the results will depend on your input values.\n"},{"id":9,"href":"/csc346/docs/homework/hw05/","title":"Homework 5","section":"Homework","content":" CSC 346 - Homework 5 # In this homework assignment we'll begin working with Amazon Web Services. You will create an EC2 instance (AWS's Virtual Machine), and run a docker container on it containing the beginnings of our image sharing client.\nWhat to turn in # yournetid-hw05/ Dockerfile html/ index.html app.html js/ app.js Points # This assignment will be worth 50 points. Turning the assignment in early will earn you an additional 5 points extra credit.\nEarly submission: March 1st 11pm MST (UTC-7) Final Due Date: March 2nd 11pm MST (UTC-7) Starting Point # For this assignment, begin by downloading the following Zip file. This contains the basic diretory structure, and some starting HTML documents. Place these files into your yournetid-hw05 directory, and add to the files as needed.\nhttps://www2.cs.arizona.edu/classes/cs346/spring24/homework/NETID-hw05.zip Part 0: Set up your AWS Academy Account # You should already have completed setting up your AWS Academy account. If you haven't done this yet, or are stuck, please contact the TAs as soon as possible. See the AWS Slides for how to set up your AWS Academy account, and VS Code CLI credentials.\nLog in to the AWS Academy Console here.\nPart 1: Set up EC2 Instance # The lecture slides for AWS-VMs go through in detail how to set up a basic EC2 instance. You should be able to follow the slides to set up your basic t3.micro EC2 instance, and get docker installed.\nBe sure you can remotely connect to your EC2 instance with SSH, either diretly in your Terminal, through PowerShell, or using Putty.\nPart 2: Working Remotely # For the rest of the assignment, you will need to figure out a reliable way to move files back and forth from your laptop to your EC2 instance, or else work on files directly on the EC2 instance.\nFor all of the following options, make sure your AWS Academy session is active and your EC2 instance is running. You will also need to make sure you have downloaded the SSH Key File from the AWS Academy console, and put it somewhere you can find. You'll need this file to connect to your EC2 instance. Lastly you will need to note the current public IP address of your EC2 instance.\nDirect Editing # If you really love vim or nano or emacs, go crazy! You'll have access to all of these tools on your Amazon Linux instance.\nRemote Editing With VS Code # VS Code has a wonderful Remote SSH plugin that works great with Amazon Linux EC2 instances. This allows you to open a local VS Code window on your laptop which is directly connected to a remote host. Once connected, you can work in VS Code exactly as you would locally, but all the files are edited directly on the remote host, and you also have access to a terminal session on the remote host as well. You can even drag and drop files from your laptop into the VS Code file browser to copy them directly to the host. Right-click on a remote file to download it to your laptop.\nThis can take some time to set up, but I have found it worth the trouble. See the VS Code Remote SSH slides for a complete walkthrough.\nVS Code Remote SSH Walkthrough Transfer files from your laptop # Many times it is easier to work on things locally on your laptop, and then move things to the server when you're done. This assignment is probably best done like this. Using the provided Dockerfile, run your container locally and build the required HTML pages and JavaScript code as described in Part 3.\nOnce you have your container working correctly, you can then move your files to the server.\nMac / Linux CLI: rsync # If you're on a macOS or Linux laptop, you can use the rsync command line tool to move all the files in a directory to a remote host.\nrsync -rlvz -e \u0026#39;ssh -i ./labsuser.pem\u0026#39; hw05/ ec2-user@\u0026lt;EC2 Public IP\u0026gt;:~/hw05/ You will need to change the ./labsuser.pem part to match your file name, and wherever you have placed your public key file downlaoded from AWS Academy. Substitute the public IP address you noted from the EC2 console ec2-user@\u0026lt;EC2 Public IP\u0026gt; ie ec2-user@18.212.36.7. The colon after the IP address separates the host IP from the path on the host you want to copy files to. ~/hw05/ means to create a hw05 directory inside the home directory of the ec2-user account.\nWindows WinSCP # If you're on Windows, WinSCP is a good choice, and has good documentation. Instead of the .pem version of the private key, you will want to download the .ppk version from the AWS Academy console.\nFollow the \u0026quot;Direct Connections\u0026quot; instructions on the WinSCP documentation site for connecting to an EC2 instance. Note that you can use the IP address or the hostname from the EC2 console. Be sure to select your .ppk file in the Advanced Site Settings \u0026gt; SSH \u0026gt; Authentication window.\nPart 3: Image Sharing Client # For the actual content of the website for this assignment, you can start with the NETID-hw05.zip file contents. You won't have to edit index.html or app.html files at all for this assignment. They will be set up for you, but it's still a good idea to take a look at them and see what's in them.\nHint: Experiment with the chat API call in Postman first, to get a feel for the structure of the data that is returned.\nGET https://csc346picturegram.test.apps.uits.arizona.edu/chat app.js # You'll be doing all your work for this assignment in the app.js file. You will need to load new chat messages from the Class Chat API and display them on a web page. The starter javascript file has extensive comments to guide you through implimenting this.\nPart 4: Run Your App on Your EC2 Instance # After you have your application working locally, we want to run it on the EC2 host you created.\nInstall Docker # If you haven't installed Docker on your EC2 instance, do that by running the following command:\nsudo yum install docker You'll need to use the sudo command before many of the installation and docker commands, since the ec2-user used to log into the EC2 host cannot run these commands directly.\nAfter Docker finishes installing, run the service now, and configure it to startup whenever your EC2 instance boots up.\nsudo systemctl start docker sudo systemctl enable docker You should be able to run basic docker commands now using sudo, such as sudo docker ps -a:\n[ec2-user@ip-172-31-21-172 ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Build Image and Run Container # Once you have Docker installed and configured, transfer your Dockerfile and html files to your EC2 instance. Navigate your CLI console to the folder containing the Dockerfile and html folder, and build the image. Don't forget to use sudo.\nsudo docker build -t hw05:latest . After the image is built, you should be able to run it. Note that since we're running this container on a \u0026quot;real\u0026quot; server host, we can use port 80 on the host to map to port 80 in the container.\nsudo docker run -it --rm -p 80:80 hw05:latest Assuming everything worked, you should be able to visit your EC2 instance by going directly to its public IP address:\nhttp://3.95.11.168/index.html To find your EC2 instance public IP address, visit the AWS EC2 Console, select the instance, and find the \u0026quot;Public IPv4 address\u0026quot;.\nPart 5: Automated Tests # With your application running on a publicly available IP address. Anyone can access your app from the public internet. This means we can also have automated tests run to see how you did.\nI have developed a testing app you can use to test out your homework assignment once you get it running on your EC2 instance. You will need to perform a test wtih this app before the due date to receive credit for the EC2 portion of this assignment. All the tests you run through the app are logged, and we will look at the most recent test results for your NetID when we do the grading. So make sure your last test is the good one. :)\nhttps://csc346.test.apps.uits.arizona.edu/ You will need to log in through WebAuth to see the URL form.\nThe tests take between 10 and 60 seconds to run, so be patient.\nYou can only test a publicly accessible URL. This cannot be used to test your http://localhost:8080/ version. Think about why this would be.\nThe automated tests do not test all of the things we will be looking at for this assignment. Passing all of these tests is a really good sign that you're on the right track. We will also be looking at your app.js file for completeness. Troubleshooting Tips # Can you visit your app's URL directly in a browser window? If you cannot load your app, the testing app won't be able to either. Check the URL. Did you enter a complete URL such as http://53.2.35.19? Does your URL use http://? We have not configured TLS support, and port 443 is not open on your security group. Make sure to use http. Did you map your docker port 80 to your host's port 80? -p80:80. Only port 80 is open on our security group to allow incomming connections. "},{"id":10,"href":"/csc346/docs/homework/hw06/","title":"Homework 6","section":"Homework","content":" CSC 346 - Homework 6 # In this homework assignment we'll continue work on our PictureGram client using our same EC2 instance from HW05.\nWhat to turn in # There are two parts to be graded for this assignment. The first part is a .zip file containing your app files. This is similar to past assignments.\nyournetid-hw06/ Dockerfile html/ favicon.ico index.html js/ app.js picturegramSDK.js The second part is testing your EC2 server deployment. See Part 5: Testing for instructions on how to do this. Your .zip file and the on-demand remote testing must be completed by the due date of the assignment.\nPoints # This assignment will be worth 50 points. Turning the assignment in early will earn you an additional 5 points extra credit.\nEarly submission: March 21st 11pm MST (UTC-7) Final Due Date: March 23rd 11pm MST (UTC-7) Starting Point # For this assignment, begin by downloading the following Zip file. This contains the basic diretory structure, and some starting HTML documents. Place these files into your yournetid-hw06 directory, and add to the files as needed.\nhttps://www2.cs.arizona.edu/classes/cs346/spring24/homework/NETID-hw06.zip Since this class is more about the Cloud Computing bits of things, and less about web app development, the JavaScript for this assignment is limited to filling in some additional functionality which is similar to some existing code that is in the starter file.\nindex.html # We don't need multiple pages anymore, so app.html has been removed, and all the logic and user interface just happens directly in index.html. You won't have to make any changes in this file, but it's a good idea to look at it and see how the markup looks, and how the JavaScript files are included.\napp.js # The main application logic still happens in app.js. There's a lot more code in the starter version, but still has some places for you to fill in functionality.\npicturegramSDK.js # I moved the API access function in to a separate file, and made it in to a class which is instantiated inside app.js. This will be similar to using Software Development Kits (SDKs) provided by 3rd party services you're likely to use. There's one main apiCall() method which is fully implimented. There are convenience methods for the rest of the functionality. Some of these are implimented in the starter kit, and others you'll impliment as part of the homework assignment.\nPart 1: Load Older Posts # The starter app will load the 5 most recent posts, basically starting where HW05 left off. For this part you will impliment a button which loads older posts when clicked.\npicturegramSDK.js # First you will impliment the getPostsBefore() method of the picturegramSDK. This will allow you to load older posts. Remove the console.log line, and replace it with code that will call this.#apiCall( ... ) correctly, and return that result. See getPosts() in the same file for an example.\nThis needs to call the posts/before/${timestamp} action of the picturegramSDK. It uses the GET http method, so be sure to specify that. The timestamp will passed in to the method in the endTime variable, so you should be able to append that value to construct your method string.\nAfter this method is implimented, the \u0026quot;Load Older Posts\u0026quot; button the the app page should work. See if you can trace the connections from user click, to button event listener, to the getPostsBefore() method and to the final HTTP API call that's made.\nPart 2: Authentication # picturegramSDK.js # Next you need to impliment the authenticate() method on the picturegramSDK class. Remove the console.log line of code containing the early return, then follow the comments to implement the rest of the functionality. Replace the undefined == undefined if check with a correct conditional.\nThis should be similar to the getPostsBefore method. You need to take the arguments passed in to the function, and build an action string which you will pass to the this.#apiCall( ... ). This API call is also a GET.\nIt will be very helpful to familiarize yourself with what a response JSON object looks like from the authenticate API call from the PictureGram API documentation.\nAsync/Await # Note that the authenticate method is marked as async. This is because we need to await the response from our apiCall so that we can process the results. If you look at the picturegramSDK, only the functions that need to deal with the response of an apiCall directly in them are async/await. The others return the Promise object from apiCall to the caller context. In all cases however, calls to the picturegramSDK that require apiCall access must be made in an async/await aware context. See the async function loadPosts implementation in app.js as an example.\nStore Auth Response # When we get the authResponse from the authenticate/${ticket}?service=${service} api call, we need to store the resulting username and jwt values as local class attributes, and also store in the browser's window.sessionStorage. This way if you reload your page, you will remain logged in and not have to authenticate each time.\nStoring the values on class attributes is as simple as assigning them to this.attributeName. Look at the top of class picturegramSDK to see the attributes that are defined as part of the class.\nStoring the information in window.sessionStorage can be done by calling the appropriate window.sessionStorage.setItem() method. See the Mozilla Developer documentation for details.\nPart 3: Check Logged In Status # After a successful login, the user interface is updated to show the username, and provide a logout link instead of a login link. In order to be able to reload the page, or leave and come back in the same browser session, we stored the username and jwt auth token in the browser's sessionStorage. Now we need to try and read these values back out again, and update the interface if we have stored values.\nisLoggedIn() # Implement the isLoggedIn() method in picturegramSDK.js. You can determine if someone is logged in or not by testing to see if the current picturegramSDK object has the authJWT attribute set, or if it is null. Replace the undefined == undefined if check with a correct conditional. If this.authJWT is null, we can try and load the username and jwt token from sessionStorage using window.sessionStorage.getItem(). If we retrieve values from sessionStorage, then we can assign those back to the local object attributes, and finally test this.authJWT again to see if we have login information now. If we do we can return true, and return false if not.\nsetup() # Finally, now that we have a method to determine if the user is logged in or not, we need to use that in the setup() function in app.js. Replace the undefined == undefined if check with a correct conditional.\nSince we assign the username and jwt values to local object attributes, we can reference them from our pg object using pg.username. If there is a logged in user, call the updateLoginButton() function and pass in pg.username. If not, call updateLoginButton() with no argument.\nTake a look at the updateLoginButton function to see what the behavior is in each case.\nPart 4: New Posts # Once you can successfully log in, the interface should update to show the new post form. There is already code connecting the \u0026quot;POST!\u0026quot; button to the handleNewPost() function in app.js. This function gets the contents of the textarea and then calls pg.createPost(), which you will implement next.\ncreatePost() # In picturegramSDK.js find the createPost() method. Implementing this will actually only involve one line of code, but there's a lot that goes into that line. Unlike the previous API calls that you have implemented, this one will use the POST HTTP method since it is sending data to the API. The API action we want to call is posts, so take a look at the PictureGram API Documentation for that method.\nAlso unlike the previous API calls, this one requires authorization, since we don't want to just allow anonymous message and image posting. So you must include the optional requiresAuth argument of the #apiCall() method. Lastly this API call needs to include the data itself to send to the server as the fourth data argument. The contents of this last argument must be a JavaScript object, with one key: message and the value from postText that is being passed in.\nNote that for this homework we only need to include the message key and value, since we don't yet support image uploads. So you can ignore the image_full_url and image_thumbnail_url keys from the documentation. The result from the #apiCall() will be returned from this method.\nOnce your API call works, the new post should show up in your client.\nYour posts are visible to your classmantes and the public. Be mindful of the Student Code of Conduct specifically section F and the prohibition on harassment, intimidation, and threats. The posts are logged to your NetID. Be respectful! Part 5: EC2 # As with homework 05, once you have the app implimented and working correctly on your local Docker environment, you need to move it to an EC2 instance so that you can access your app live on the internet. See Part 4 from Homework 5 for details on running your app on your EC2 instance.\nYou will need to set up an EC2 instance, and complete the following tasks:\nInstall docker Start the docker service Copy your homework 6 files to the EC2 host (Dockerfile, html, js etc) Build your docker image on the EC2 host Run your docker image on the EC2 host When you run your docker image on the EC2 host, you want the publicly available port to be maped to 80, instead of 8080 as we've been doing locally. This matches with the security group configurations around your EC2 instance.\nThe docker service runs as root on your EC2 instance, so you will need to use the sudo command before your docker commands to elevate your current user privileges.\nsudo docker build -t homework06:latest . sudo docker run -i --rm -p80:80 homework06:latest Part 6: Testing # I have updated the testing app you can use to test out your homework assignment once you get it running. All the tests you run through the app are logged, and we will look at the most recent test results for your NetID when we do the grading. So make sure your last test is the good one. 😀\nhttps://csc346.test.apps.uits.arizona.edu/ You will need to log in through WebAuth to see the URL form.\nThe tests take between one to two minutes to run, so be patient.\nYou can only test a publicly accessible URL. This cannot be used to test your http://localhost:8080/ version. Think about why this would be.\nI am not doing a full test of all the functionality required for this homework. I am only performing 4 tests remotely:\nCan your application be accessed, and does the resulting URL match the one entered. Are there 5 initial chats when the page loads. Does the #olderchatsbutton button exist, and load more chats when clicked. Is there a Login link with an href attribute pointing to the correct URL. Creating new posts still needs to work! We will test that separately when we grade the assignment.\nTroubleshooting Tips # Can you visit your app's URL directly in a browser window? If you cannot load your app, the testing app won't be able to either. Check the URL. Did you enter a complete URL such as http://53.2.35.19? Does your URL use http://? We have not configured TLS support, and port 443 is not open on your security group. Make sure to use http. Did you map your docker port 80 to your host's port 80? -p80:80. Only port 80 is open on our security group to allow incomming connections. "},{"id":11,"href":"/csc346/docs/homework/hw07/","title":"Homework 7","section":"Homework","content":" CSC 346 - Homework 7 # In this homework assignment you will deploy two serverless Lambda functions to faciliate image uploading for the Picturegram client. You will create two S3 buckets to hold the uploaded and resized image files. The first Lambda function will be for generating one-time-use signed upload URLs for uploading original images to the upload bucket. The second lambda function will trigger on new objects in the upload bucket, resize the images to standard sizes, and then store the resized images in a second S3 bucket which will be used as the source for images displayed in the Picturegram front end application.\nWhat to turn in # Turn in a .zip file of a folder containing the following files:\nyournetid-hw07/ resize-bucket-permissions.png (or .jpg) upload-bucket-permissions.png (or .jpg) image-urls.txt Points # This assignment will be worth 50 points. Turning the assignment in early will earn you an additional 5 points extra credit.\nEarly submission: April 11th 11pm MST (UTC-7) Final Due Date: April 13th 11pm MST (UTC-7) Starting Point # The starter zip for this assignment contains the python code that will be used for the Lambda functions. While I encourage you to read through the code files (they aren't long), this assignment focuses more on deploying and configuring the Cloud Infrastructure components, and not on the lambda code itself.\nhttps://www2.cs.arizona.edu/classes/cs346/spring24/homework/NETID-hw07.zip Part 1: S3 buckets # To start, create two S3 buckets from the provided template. One should be for receiving the uploaded original images. The second will hold the resized images for download by your app.. I'll refer to these as the upload bucket and the download bucket in the assignment.\nRefer to the Week 11 slides for creating the S3 buckets based on the supplied CloudFormation template.\nhttps://fischerm-csc346-download.s3.amazonaws.com/s3_template.yaml Once your S3 buckets are deployed, check them out in the AWS S3 console, and take a screenshot of the Permissions tab for each bucket. Names these images \u0026quot;upload-bucket-permissions\u0026quot; and \u0026quot;download-bucket-permissions\u0026quot;. They can be PNG files or JPEG files, what ever your screenshots come in.\nPart 2: Signed Upload URL Lambda Function # The first Lambda function will generate signed URLs that can be used to upload files directly to the upload bucket. This is really useful for us in that we don't need to wory about local disk space on an EC2 instance or anything. Files can go directly from the user's browser to the S3 bucket. You do not need to add the Lambda Layer to this function, as it does not need any additional python modules.\nUse generateurl.py from the starter zip file for the code for this function.\nRefer to the Week 11 slide 63 for creating this function. The Function URL used to call the Lambda function is found under Configuration → Function URL.\nThe upload function does not need a trigger configured. It will be invoked from the Function URL you configure.\nEnvironment Variables # Both Lambda functions need to know infromation about your S3 buckets. We can pass this information into the code through the use of Environment Variables. Select the Confifuration tab of the lambda function, then \u0026quot;Environment variables\u0026quot; in the left sidebar. You will need to create two env vars for the generateurl.py lambda function containing your two S3 bucket names. The generate URL function needs to know both of them. The S3_UPLOAD_BUCKET_NAME is used to create the presigned URL returned from this function, which your app will use to actually upload the image. The S3_DOWNLOAD_BUCKET_NAME is used to construct the URLs of the resulting images that will be created after the resize function runs. These URLs are also returned as part of the response, even though technically they won't be valid for a breif time while the resize function actually gets to work after the image is uploaded.\nTesting Signed Upload URL Function # To test out your first lambda function, find the URL created when you set up the Function URL. Take this URL to Postman or curl and use it to test out the function. Remember that you need to include a query string parameter with the name of the file you intend to upload. For testing this can literally be any string, when we get to integrating this into our PictureGram client, we will take the filename off of whatever file we select to upload.\nThe query string parameter key is filename and the value is whatever image you want to upload. Grab some tasteful image that's somewhat large to test with, something at least 1500px x 600px so we have something to resize.\nYour images are visible to your classmantes and the public. Be mindful of the Student Code of Conduct specifically section F and the prohibition on harassment, intimidation, and threats. Be respectful! curl -v https://alw676it2cnnrshan3627wop7m0eampr.lambda-url.us-east-1.on.aws/?filename=oldmain.jpg You should get a JSON response that looks something like:\n{ \u0026#34;status\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;upload_url\u0026#34;: \u0026#34;https://fischerm-csc346-upload.s3.amazonaws.com/input/oldmain-d8365602-a16a-43fc-88de-17cb345e1866.jpg?AWSAccessKeyId=ASIAT5UK7QF4Q43HMI54\u0026amp;Signature=p8mVTma3gl94ntFIHBMCbp7vI84%3D\u0026amp;content-type=image%2Fjpeg\u0026amp;x-amz-security-token=IQoJb3JpZ2luX2VjEBUaCXVzLWVhc3QtMSJHMEUCIQCBieHTs0PzOtDQKiwpDqaO9RZ30abeDZLAj19BHoCKbwIgcrAjrTkepINuJVE2iM81aus35dSIeVescPvY9SFjNR8qtQMIPRAEGgwyNjk4MDA2Njk1NjEiDDOc%2B2UTp%2FZrStOJWSqSA3zz%2B%2FdRG2Y19iHSgt8tjXCvVImIEVZXp4TYoFbrRY4citEHQbxY2Qq8A3KTTxUQAZWpOX9tP0ARpC0CURpZEyR373R5dgn%2BXH2mv5zEOuWIhdg4QtidD1pEAq7Wari%2FqRvPzaoAxxWRFwarRExoYyAOYEfZIi21VbLMuLiOyt2vTQaubUg1aqucxHPOxVW32YXkgFk2if2ZCZZlBFbC4z6dlIFT6qOF%2FVKc9K8EcTh3v5aJKeQJ%2FgqRQ492jMgmpOrWirZbSD8Wuk1DEsZTRC6OAlTkeic6%2FV9k0paQdbFTqg7BJky9P4k8EgwXrjtGMPLBpd%2FeUicC5AL4MC%2BkjZgi7liGq6A8r3tLpnhnwwwbJL%2BZry1my6Rtm9SRkUp1DnkNOZy5jXgOyRptvO0tTwZovVruO94sKggTOY%2B66YwRwIrVqHrARD36Cj0gE76bwUEhUU7rdylV6ciI5u9Pm0BskrbIhyIVDGNbmAyr%2FAs5LYCZlpxkee0WA5If0ZU14cUXr1jKYmSX3J9xI6N6StB9CzDx5KiwBjqeAYcvA%2FrUNFCdLFP%2Fm2srf9A6vmN3vNiBfivdFDE8m%2Fcvazu8DgIQg64stYCktFuAGYzxRsuaDHPCW3VuD%2FyTXtMd6tXiIcAExBVNny4l3N7ZyOJ7TSJLFRpqyjjHG%2FNxOvWKKnaGCdaqRq7F%2B3baA6ryUXO%2FJgIYKvjg56NfUGGWMK%2B0WStQ%2FtZZl0CS45QY%2BDxaAfD0yEhqJT1rf3Lf\u0026amp;Expires=1711944606\u0026#34;, \u0026#34;full_url\u0026#34;: \u0026#34;https://fischerm-csc346-download.s3.amazonaws.com/oldmain-d8365602-a16a-43fc-88de-17cb345e1866-scale1500.jpg\u0026#34;, \u0026#34;thumbnail_url\u0026#34;: \u0026#34;https://fischerm-csc346-download.s3.amazonaws.com/oldmain-d8365602-a16a-43fc-88de-17cb345e1866-crop600.jpg\u0026#34; } The upload_url attribute in the response contains the URL you will use to actually upload the image to the S3 bucket. This can again be done with either Postman or curl, although I find Postman easier.\nRefer to the Week 11 slide 65 for Postman examples.\nThe presigned upload URLs are only valid for 5 minutes (300 seconds, see the code). You may have to generate a new URL periodically while testing. There's no penalty or cost to calling the Signed Upload URL lambda function. You'll only be charged for the images that actually get uploaded. Part 3: Image Resizing Lambda Function # The next Lambda function will resize any image that shows up in the upload bucket. It will make two standard sized images from this, and store them in the download bucket.\nNote that you will not test your function in the same way the slides show. The final function code provided assumes event data is coming in that matches an S3 CreateObject event. So you still need to Deploy your function code whenever you make changes, but the testing will be done by just uploading a new image to the upload bucket, and then checking the resize bucket and CloudWatch Logs. See the Troubleshooting section below for more information about CloudWatch Logs.\nUse resize_image.py from the starter zip file for the code for this function.\nRefer to the Week 11 slides 31 for creating the Lambda function.\nEvent Trigger # You need to add an event trigger to the resize function. This is what connects new files showing up in the upload bucket, to triggering this function to run. Refer to the Week 11 slides 41 for adding triggers.\nBe sure to trigger on the UPLOAD s3 bucket, and set the S3_DOWNLOAD_BUCKET_NAME environment variable to your DOWNLOAD bucket. If you use the same bucket name in both places you can create an infinite recursive loop! Go ahead and include the input/ prefix when setting up the trigger. This can help prevent against accidental recursive problems. The generateurl.py function has this prefix defined when it creates the presigned uplaod URLs. This means all your uploaded images should end up in this 'folder'. The resize_image.py code puts all the resized images at the root level of the S3 bucket. So in the unlikely event you get your buckets crossed, hopefully this difference prevents the resized images from triggering additional resize function executions, since they won't be in the input/ folder. Lambda Layer # In order to use the imaging modules, you need to have the correct python modules available within your lambda runtime. I've packaged these up in a Lambda Layer that you can reference. Refer to the Week 11 slides 45 for adding triggers.\narn:aws:lambda:us-east-1:269800669561:layer:fischerm-csc346-imagelayer:5 Environment Variables # The resize function only needs to have your S3_DOWNLOAD_BUCKET_NAME set. The upload file names and bucket names will come in as part of the event object passed to your lambda handler as a result of getting the Event Trigger connected.\nBe sure to trigger on the UPLOAD s3 bucket, and set the S3_DOWNLOAD_BUCKET_NAME environment variable to your DOWNLOAD bucket. If you use the same bucket name in both places you can create an infinite recursive loop! Part 4: Upload an Image # If all goes well, you should now be able to generate an upload URL, and then use that URL to upload an image to your upload bucket. Once there, your resize function should have been triggered to grab the original, resize it, and save the resized images in the resize bucket.\nCreate a text file named image-urls.txt. Upload a test image for resizing, and include three URLs in the image-urls.txt text file:\nOriginal URL: Thumbnail URL: Large URL: The Thumbnail and Large URLs should be able to be viewed by anyone in a browser. We will examine these URLs as part of the grading. The Original URL is the file uploaded to your upload bucket. These won't be publically visible, but the TAs and I can look at the contents of your S3 bucket to verify it.\nPart 4: Automated Testing # I have updated the testing app you can use to test out your homework assignment once you get it running. All the tests you run through the app are logged, and we will look at the most recent test results for your NetID when we do the grading.\nhttps://csc346.test.apps.uits.arizona.edu/ You will need to log in through WebAuth to see the URL form.\nThe input URL will be the Function URL for your Generate Upload URL Lambda function, ie https://xxxxxxxxxxxxxx.lambda-url.us-east-1.on.aws/\nThe tests take between 15 and 30 seconds to run, so be patient.\nTroubleshooting # CloudFormation Stack Deployment Errors # If you have problems deploying the S3 CloudFormation stacks, double check that the URL is correct when specifying the S3 template URL. Also check the Events tab of the stack to see what errors show up there. Bring errors to the Discord class channel and we'll work through them.\nLambda Function Execution Errors # Your Lambda functions will be executed in two ways. The resize function is triggered whenever a new image shows up in the upload bucket. The upload function is executed when you send a GET API request to the Function URL. In any case, you don't have direct access to the Lambda console to see any errors.\nAWS Lambda integrates with the CloudWatch Logs service to store all the log files generated. Search for CloudWatch in the services bar, and then select Log groups in the sidebar. You will get one log group for each Lambda function. Look at the individual log streams in there for possible errors.\nUpload URL Errors # If you get a \u0026quot;Forbidden\u0026quot; error when trying to hit your upload-url Function URL in postman:\n{ \u0026#34;Message\u0026#34;: \u0026#34;Forbidden\u0026#34; } Check the configuration on your Function URL. Be sure that the Auth setting is \u0026quot;NONE\u0026quot;.\nFile Upload Errors # If you get a \u0026quot;signature does not match\u0026quot; error when trying to upload the file to your signed upload URL, check and make sure that the HTTP method is PUT. Also maje sure that the image file type matches what you requested in the upload-url call. For example if you requested filename=image.jpg you need to upload an image of type JPEG, with either a .jpg or .jpeg extension. The Content-Type header must match the signed URL.`\n"},{"id":12,"href":"/csc346/docs/homework/hw08/","title":"Homework 8","section":"Homework","content":" CSC 346 - Homework 8 # In this homework assignment you will deploy The PictureGram App from Homework 6 in AWS with the Elastic Container Service and an Application Load Blancer instead of directly on EC2. We'll also integrate the image upload system from homework 7 in to the app.\nYou will need to create an Elastic Container Registry (ECR) repository to hold your docker image, and the build and push the image up. Then you will need to import an SSL TLS certificate to use on our Application Load Balancer. Then you'll need to collect a few bits of information to use in deploying the CloudFormation template. Lastly I will have an updated automated test app site for you to use to test your infrastructure deployments.\nWhat to turn in # Turn in a .zip file of a folder containing the following files:\nyournetid-hw08/ notes.txt Dockerfile html/ favicon.ico index.html js/ app.js picturegramSDK.js Points # This assignment will be worth 60 points. Turning the assignment in early will earn you an additional 10 points extra credit.\nEarly submission: April 25th 11pm MST (UTC-7) (+10 points) Original Due Date: April 27th 11pm MST (UTC-7) (+5 points) Final Due Date: April 30th 11pm MST (UTC-7) Starting Point # The starter zip for this assignment contains the Web Application and Dockerfile needed to build the application image, as well as the CloudFormation template to be used to dpeloy the infrastrucutre resources.\nhttps://www2.cs.arizona.edu/classes/cs346/spring24/homework/NETID-hw08.zip Part 0: Update S3 CloudFormation Template and Function URL # I had a mistake in the CloudFormation Template from Homework 7. In order to interact with the Upload S3 bucket with JavaScript in a web browser, CORS must be configured correctly on both buckets. I left off the CORS configuration from the Upload bucket in the homework 7 template.\nThere is an updated template in this assignment's starter ZIP, s3_template_cors.yaml.\nCloudFormation Console # In your AWS console, navigate to the CloudFormation service. Locate the stack you created to deploy the two S3 buckets. Click on the resources tab to see that you have the correct stack.\nUpdate S3 Stack # With the stack selected, click on the \u0026quot;Update\u0026quot; button near the top. On the update screen, select \u0026quot;Replace existing template\u0026quot;. Then \u0026quot;Upload a template file\u0026quot;. Click the \u0026quot;Chose file\u0026quot; button, and select the s3_template_cors.yaml file from the starter ZIP. Then click \u0026quot;Next\u0026quot;\nWe don't need to change the stack name, parameters, or any other stack settings, so you can click \u0026quot;Next\u0026quot; through the Parameters screen and Configure stack options screen. When you get to the Review screen, scroll down and click \u0026quot;Submit\u0026quot;.\nYou can watch the progress on the \u0026quot;Events\u0026quot; tab. The update should only take 30 seconds or so. Once the stack reaches \u0026quot;UPDATE_COMPELTE\u0026quot; you're done.\nLambda Function URL CORS Configuration # In homework 7, we only interacted with your lambda functions directly through Postman or curl. When trying to use the Function URL in JavaScript, modern browser enforce a security model called \u0026quot;Cross-Origin Resource Sharing\u0026quot; commonly abreviated as CORS.\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/CORS Navigate to the AWS Lambda console, and select your Generate Upload URL function. In the \u0026quot;Configuration\u0026quot; tab, select \u0026quot;Function URL\u0026quot; from the sidebar and click \u0026quot;Edit\u0026quot;.\nExpand the \u0026quot;Additional settings\u0026quot; section, and check \u0026quot;Configure cross-origin resource sharing (CORS)\u0026quot;. You can leave everything in the CORS section as defaults except for the \u0026quot;Allow methods\u0026quot; section. You need to check GET for that. Then click the \u0026quot;Save\u0026quot; button and that should be it for updates.\nPart 1: Upload Attached Images # Here, you will tie in your image upload API system from homework 7. You will need to set your Function URL from your generate upload URL Lambda function as generateApiFunctionUrl at the top of app.js.\nSee the PART 1 comments in app.js for more details on what code to complete. There are sections to complete in the checkUploadImage() and handleNewPost() functions in app.js.\nPart 2: Update Chat POST with Image URLs # After an image is uploaded to your S3 bucket, and they've been resized, you need to include the new fullsize and thumbnail image URLs with the createPost API call. You will need to update the handleNewPost() function in app.js and the createPost() method in picturegramSDK.js. See the STEP 2 comments in those files for details.\nAs you test this part, I recommend un-commenting the debug line near the bottom of picturegramSDK.js. This will return an empty Promise object instead of actually calling the POST chat API, potentially saving you from uploading a bunch of chats with broken image URLs as you figure things out.\n// return Promise.resolve({\u0026#34;status\u0026#34;: \u0026#34;error\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;short circuit\u0026#34;}) I also included a sample image you can use for testing if you don't want to hunt down your own.\nIf all goes well, you should be able to include an image when you post a new chat message!\nPart 3: Elastic Container Registry # We need to create an ECR repository to hold our build docker images. Since this is a pretty simple resource, it is easy to just create it manually in the AWS web console.\nLog in to your AWS Academy account, start the lab, and access the AWS web console. Search for \u0026quot;ECR\u0026quot; and then click on the \u0026quot;Create repository\u0026quot; button. Leave all the settins as their default, and fill in the repository name.\nAfter creating the repository, click on the \u0026quot;Show Push Commands\u0026quot; button. You probably want to copy these to a notes file, or make a bash/powershell script to store that command to avoid having to come back here to get the login and push commands again.\nFind the notes.txt file from the starter ZIP and use it to record the various commands and values you'll need for this assignment:\nDocker Login Command: Docker Build Command: Docker Push Command: Image URI: TLS Cert ARN: LabRole ARN: VPC ID: Subnet IDs: LoadBalancerDNSName: Copy the Docker commands into notes.txt.\nPart 4: Build and Push Your Docker Image # Before you can build and push your docker image, you must ensure that your AWS CLI credentials have been updated. Copy in the current values from the AWS Academy site into your ~/.aws/credentials file.\nYou will need to have the AWS CLI v2 tools installed to log in to the AWS ECR and push your Docker image up. See https://aws.amazon.com/cli/ for instructions. Apple Silicon Mac Users!\nYou will need to add an additional option to your docker build command to make sure you build for the correct architecture.\nAdd --platform linux/amd64 before the -t ... option in the commands you copy from the ECR repository. Somthing like:\ndocker build --platform linux/amd64 -t csc346-app . Once your image is uploaded, record the URI for your image in your Notes file.\nPart 5: AWS Certificate Manager # Next, we need to upload a TLS (transport layer security) certificate for you to use on your Application Load Balancer to provide encryption for the application. Because we'll be using the .arizona.edu Domain Name, the certificate itslef needs to be issued by someone with the authority to issue certificats on the behalf of the University of Arizona. UITS does that for us fortunately!\nIn the services search bar of the AWS web console, search of \u0026quot;ACM\u0026quot; and go to the Certificate Manager console. From there click on the \u0026quot;Import\u0026quot; button to set up our certificate.\nIf you see a big red \u0026quot;Failed to list certificate authorities\u0026quot; error, you clicked on the \u0026quot;Request\u0026quot; button. Go back and click on \u0026quot;Import\u0026quot;. There are three text fields you need to fill with the contents of the certificates files from the starter kit:\nCertificate body: csc346_arizona_edu_cert.cer Certificate private key: csc346_arizona_edu_cert.key Certificate chain: csc346_arizona_edu_interm.cer Copy the contents of each of the files into the associated text fields, then click the \u0026quot;Next\u0026quot; button. We don't need to add any tags to this, so click \u0026quot;Next\u0026quot; again, and then \u0026quot;Import\u0026quot; on the \u0026quot;Review and import\u0026quot; screen.\nIf you don't see your certificate right away, reload the page. Then click on your certificate to see the details, and copy the ARN to your Notes file.\nPart 6: Gather Remaining Parameter Values # The last bits of information you need to deploy the CloudFormation template are to find your Lab Role ARN, VPC ID, and Subnet IDs.\nLab Role ARN # Roles are located in the IAM service console, so find that from the services search bar, and then click on \u0026quot;Roles\u0026quot; in the left sidebar. Scroll down to find the \u0026quot;LabRole\u0026quot;, then click it to view the details. Copy the ARN of the role to your Notes file.\nVPC ID # To find the VPC ID for your account, search for the VPC service in the search bar. You should just have one default VPC. Copy its ID to your Notes file.\nVPC Subnet IDs # Lastly we'll need two Subnet IDs to reference in our Application Load Balancer config. From the VPC console, click on \u0026quot;Subnets\u0026quot; in the left sidebar. We need two of these, but it doesn't matter which two. Copy their values to your Notes text file as a comma separated list.\nPart 7: CloudFormation Deployment # You should be ready to deploy the CloudFormation template now. Go to the CloudFormation console in AWS, and create a new stack with new resources.\nUpload the ecs_template.yaml file from the starter ZIP, and fill in the Parameters from your Notes file.\nClick through \u0026quot;Next\u0026quot; and \u0026quot;Next\u0026quot; and finally \u0026quot;Submit\u0026quot; the template. Once the stack completes, click on the \u0026quot;Outputs\u0026quot; tab to see the DNS name for the Application Load Balancer. Copy this to your Notes file as well, you will need that to put in on the automated testing app to connect the DNS.\nIf you click on the DNS name value, it will attempt to open that in a new browser tab. However you will see some sort of certificate error depending on your browser. Recall that the TLS certificate we assigned to the ALB is only valid for *.csc346.arizona.edu, and that's not the current name of the ALB. We need to add an additional DNS CNAME record to point yournetid.csc346.arizona.edu at the value for your ALB's existing DNS entry.\nPart 8: Re-Deploy Your ECS Service # If you change your code, you need to build and push the new Docker image to your ECR repository. You can then trigger a service re-deployment to get your updated application image in to use.\nLog in to the AWS Console, and go to the ECS console. Then find the ECS Cluster for your app. Click on the cluster name to view the details.\nFrom the Cluster details page, click on the name of the Service for your chat app to look at its details.\nClick on Update Service\nCheck the \u0026quot;Force new deployment\u0026quot; checkbox.\nScroll to the bottom of that page and click \u0026quot;Update\u0026quot;. From there you can return to the Service tab, click on your service, and then monitor the Events tab to see the new container get deployed, and the service reach a new steady state. From there you should be able to test your newly deployed app at https://yournetid.csc346.arizona.edu/ and then submit it for automated testing.\nPart 9: Automated Testing # The testing website has been updated for Homework 8.\nhttps://csc346.test.apps.uits.arizona.edu Once you have deployed your CloudFormation stack, go to the Outputs tab on the deployed stack, and copy the DNS name of your Application Load Balancer. It should look something like csc34-LoadB-1P83SOIQSA2SJ-1369304737.us-east-1.elb.amazonaws.com. The first time you visit the testing site, you will need to put in your ALB DNS name into the field to set it and run the tests. This will create a DNS CNAME entry for yournetid.csc346.arizona.edu to your ALB. If you run in to a net::ERR_NAME_NOT_RESOLVED, go back and try running tests again. Sometimes the DNS records take a minute to be fully resolve.\nOnce you've set your DNS record, you don't need to keep putting in a value to the DNS record field. You can just test your saved record.\nTroubleshooting # As errors are reported to me, I will update this section with additional troubleshooting ideas.\nCloudFormation Stack Deployment Errors # If you have problems deploying the S3 CloudFormation stacks, double check that the URL is correct when specifying the S3 template URL. Also check the Events tab of the stack to see what errors show up there. Bring errors to the Discord class channel and we'll work through them.\nFAILED Test Results # net::ERR_NAME_NOT_RESOLVED # If you hit this error which will cause all your tests to fail, go back and reload the page and try running tests again in a few minutes. Sometimes it can take up to 5 minutes to fully propogate the new DNS records everywhere.\nDocker Issues # Error saving credentials: error storing credentials - err: exit status 1, out: 'Post \u0026quot;http://ipc/registry/credstore-updated\u0026quot;: dial unix backend.sock: connect: no such file or directory'\nDocker is not running on your local computer. Start up Docker Desktop first and try again.\nCORS Issue # origin has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource.\nYou are probably just loading your index.html file directly in the browser. Check the URL field in your browser. If it starts with file:///... then you're doing this. For AJAX/Fetch calls to work, the page must be loaded from a web server. Run your app's docker container, and access your app via http://localhost:8080/ instead.\nYou also may have not updated the Upload S3 bucket. See Step 0 above.\nAlternatively, if you are accessing it through a web server, either at http://localhost:8080 or at https://yournetid.csc346.arizona.edu and you're still seeing the CORS error, and you're running in to this error when trying the fetch() call to generate the signed upload URL, it might be the Function URL settings. In your generate upload URL Lambda function, check the Function URL configuration, and make sure that CORS is checked, and that the Allow origin field has an asterisk in it: *.\n503 Service Unavailable # If your CloudFormation stack seems to hang on deploying the \u0026quot;Service\u0026quot;, it may be that your ECS Service never reaches a steady state. The ALB doesn't have a healthy backend host, and so displays the 503 Service Unavailable error message. You can check this by navigating to the Elastic Container Service, clicking on your Cluster, and then clicking on the service link in the Services section. Then go to the \u0026quot;Events\u0026quot; tab. If you see a long series of register target, deregister target, draining target etc, you're likely in this situation.\nCheck the \u0026quot;Logs\u0026quot; tab, and see if you have a bunch of errors like this:\nexec /docker-entrypoint.sh: exec format error If you do, you have an incompatible Docker image architecture. So far we've only see this for users who have the newer Apple Silicon Mac computers. In that case you need to add an additional option to your docker build command:\ndocker build --platform linux/amd64 -t csc346-chat-app . Once you rebuild your image, you will need to re-tag it and re-upload it to your ECR. You should not have to delete or re-deploy the CloudFormation stack. Just wait 5-10 minutes and hopefully your image should load.\nJavaScript Files Never Update # Your browser will agressivly cache javascript files from 'real' websites, and now your app is pretty much a real website. You will need to either clear your browser's cache files for that page, or hold down the Shift key on your keyboard when clicking the Reload button. That should force the browser to download fresh copies of your JavaScript files from the server.\nSee the Troubleshooting section from Homework 3 for more ways to deal with browser cacheing.\n"},{"id":13,"href":"/csc346/docs/examples/picturegram-api/","title":"PictureGram API","section":"Examples","content":" PictureGram API # This Sample API specification describes how a client will interact with a Sample API, but does not describe how the API functionality is implimented.\nReference API Endpoint # The endpoint base URL is:\nhttps://csc346picturegram.test.apps.uits.arizona.edu/ This is used as the base URL for all API methods described below.\nGET /healthcheck # Returns a basic healthcheck for the API. Useful for testing out if you are able to connect to the API, and if the API can access all of the information it needs. If query string arguments are passed as part of the URL, they will be echoed as part of the request section.\nRequest HTTP GET /healthcheck?fruit=apple HTTP/1.1 Host: csc346picturegram.test.apps.uits.arizona.edu curl curl --location --request GET \\ \u0026#39;https://csc346picturegram.test.apps.uits.arizona.edu/healthcheck?fruit=apple\u0026#39; Response 200\n{ \u0026#34;status\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;request\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/Prod/healthcheck\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;HTTP/1.1\u0026#34;, \u0026#34;sourceIp\u0026#34;: \u0026#34;67.1.115.222\u0026#34;, \u0026#34;userAgent\u0026#34;: \u0026#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:122.0) Gecko/20100101 Firefox/122.0\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\u0026#34;, \u0026#34;accept-encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;accept-language\u0026#34;: \u0026#34;en-US,en;q=0.5\u0026#34;, \u0026#34;content-length\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;csc346picturegram.test.apps.uits.arizona.edu\u0026#34;, \u0026#34;sec-fetch-dest\u0026#34;: \u0026#34;document\u0026#34;, \u0026#34;sec-fetch-mode\u0026#34;: \u0026#34;navigate\u0026#34;, \u0026#34;sec-fetch-site\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;sec-fetch-user\u0026#34;: \u0026#34;?1\u0026#34;, \u0026#34;upgrade-insecure-requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:122.0) Gecko/20100101 Firefox/122.0\u0026#34;, \u0026#34;x-amzn-trace-id\u0026#34;: \u0026#34;Root=1-65c42df0-5f4ee70e0bf634c72db3126a\u0026#34;, \u0026#34;x-forwarded-for\u0026#34;: \u0026#34;67.1.115.222\u0026#34;, \u0026#34;x-forwarded-port\u0026#34;: \u0026#34;443\u0026#34;, \u0026#34;x-forwarded-proto\u0026#34;: \u0026#34;https\u0026#34; }, \u0026#34;queryString\u0026#34;: \u0026#34;fruit=apple\u0026#34; } } GET /authenticate/\u0026lt;ticket\u0026gt;?service=\u0026lt;serviceURL\u0026gt; # Attempts to validate a CAS ticket and returns an API session key. This requires a query string argument containing the serviceURL to authenticate as inaddition to the CAS ticket to validate. This serviceURL must match the one used when calling the GET /login action.\nRequest HTTP GET /authenticate/ST-1662939?service=\u0026lt;serviceURL\u0026gt; HTTP/1.1 Host: csc346picturegram.test.apps.uits.arizona.edu curl curl --location --request GET \\ \u0026#39;https://csc346picturegram.test.apps.uits.arizona.edu/authenticate/ST-1662939?service=\u0026lt;serviceURL\u0026gt;\u0026#39; Response 200\n{ \u0026#34;status\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;jwt\u0026#34;: \u0026#34;eyJ0eXAiO.eyJ1aWQiOiJm...aXNjaGVybSIsIml.MxKiIhc_6hbz2rpjzGo\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;yournetid\u0026#34; } Response 400\n{ \u0026#34;status\u0026#34;: \u0026#34;ERROR\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Invalid Ticket: \u0026lt;error\u0026gt;\u0026#34; } GET /users # Get a list of all the users of this service.\nRequest HTTP GET /users HTTP/1.1 Host: csc346picturegram.test.apps.uits.arizona.edu curl curl --location --request GET \\ \u0026#39;https://csc346picturegram.test.apps.uits.arizona.edu/users\u0026#39; Response 200\n{ \u0026#34;status\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;users\u0026#34;: [ { \u0026#34;usernam\u0026#34;: \u0026#34;fischerm\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Mark Fischer\u0026#34; }, { \u0026#34;usernam\u0026#34;: \u0026#34;ym1014\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Yingjie Ma\u0026#34; }, { \u0026#34;usernam\u0026#34;: \u0026#34;harshitanarnoli\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Harshita Narnoli\u0026#34; } ], \u0026#34;numusers\u0026#34;: 3 } POST /posts # Create a new post. This action requires you to pass a JWT authentication token in as a Bearer token in an Authorization header. The body of the POST contains the message to add. The username is retrieved from the JWT auth token, and the timestamp is logged on the API server.\nProperties # Key Notes Required message The text of the post. Yes image_full_url URL to a full-size image. Do not set this if there is no image for this post. No image_thumbnail_url URL to a thumbnail image. Do not set this if there is no image for this post. No body\n{ \u0026#34;message\u0026#34;: \u0026#34;This is some new message for a post.\u0026#34;, \u0026#34;image_full_url\u0026#34;: \u0026#34;https://example.com/fullsize_image.jpg\u0026#34;, \u0026#34;image_thumbnail_url\u0026#34;: \u0026#34;https://example.com/thumbnail_image.jpg\u0026#34;, } Request HTTP POST /posts HTTP/1.1 Host: csc346picturegram.test.apps.uits.arizona.edu Authorization: Bearer eyJ0eXAiOiJKV1QiLC...You2iKxkAh8_Dr1lS0 Content-Type: application/json { \u0026#34;message\u0026#34;: \u0026#34;This is some new message to post in a post.\u0026#34; } curl curl --request POST \u0026#39;https://csc346picturegram.test.apps.uits.arizona.edu/posts\u0026#39; \\ --header \u0026#39;Authorization: Bearer eyJ0eXAiOiJKV1QiLC...You2iKxkAh8_Dr1lS0\u0026#39; \\ --header \u0026#39;Content-Type: application/json\u0026#39; \\ --data-raw \u0026#39;{ \u0026#34;message\u0026#34;: \u0026#34;This is some new message to post in a post.\u0026#34; }\u0026#39; Response 200\n{ \u0026#34;status\u0026#34;: \u0026#34;OK\u0026#34; } GET /posts # Get a list of posts. Currently this returns only the first 5 recent posts.\nRequest HTTP GET /posts HTTP/1.1 Host: csc346picturegram.test.apps.uits.arizona.edu curl curl --location --request GET \\ \u0026#39;https://csc346picturegram.test.apps.uits.arizona.edu/posts\u0026#39; Response 200\n{ \u0026#34;status\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;count\u0026#34;: 3, \u0026#34;messages\u0026#34;: [ { \u0026#34;image_thumbnail_url\u0026#34;: \u0026#34;https://example.com/images/DSC7866-sm.jpg\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Congratulations! If you\u0026#39;re seeing these posts then you\u0026#39;ve probably got your basic app working.\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;fischerm\u0026#34;, \u0026#34;image_description\u0026#34;: \u0026#34;Night time celebration of students in graduation gowns in the forground, with fireworks exploading in the background.\u0026#34;, \u0026#34;image_full_url\u0026#34;: \u0026#34;https://example.com/images/DSC7866.jpg\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;chat\u0026#34; \u0026#34;timestamp\u0026#34;: \u0026#34;1708811130.770543\u0026#34;, }, { \u0026#34;message\u0026#34;: \u0026#34;Another sample post with no image attached.\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;fischerm\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;chat\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;1708811082.482178\u0026#34; }, { \u0026#34;message\u0026#34;: \u0026#34;Initial message post.\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;fischerm\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;chat\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;1708811045.597851\u0026#34; } ], \u0026#34;last_message_timestamp\u0026#34;: \u0026#34;1664771391.765176\u0026#34; } GET /posts/after/\u0026lt;startTime\u0026gt; # Get a list of posts that were posted after the startTime. The startTime slot should be a seconds based timestamp with optional decimal, such as 1664848042.519957.\nRequest HTTP GET /posts/after/1664848042.519957 HTTP/1.1 Host: csc346picturegram.test.apps.uits.arizona.edu curl curl --location --request GET \\ \u0026#39;https://csc346picturegram.test.apps.uits.arizona.edu/posts/after/1664848042.519957\u0026#39; Response 200\n{ \u0026#34;status\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;count\u0026#34;: 3, \u0026#34;messages\u0026#34;: [ { \u0026#34;image_thumbnail_url\u0026#34;: \u0026#34;https://example.com/images/DSC7866-sm.jpg\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Congratulations! If you\u0026#39;re seeing these posts then you\u0026#39;ve probably got your basic app working.\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;fischerm\u0026#34;, \u0026#34;image_description\u0026#34;: \u0026#34;Night time celebration of students in graduation gowns in the forground, with fireworks exploading in the background.\u0026#34;, \u0026#34;image_full_url\u0026#34;: \u0026#34;https://example.com/images/DSC7866.jpg\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;chat\u0026#34; \u0026#34;timestamp\u0026#34;: \u0026#34;1708811130.770543\u0026#34;, }, { \u0026#34;message\u0026#34;: \u0026#34;Another sample post with no image attached.\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;fischerm\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;chat\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;1708811082.482178\u0026#34; }, { \u0026#34;message\u0026#34;: \u0026#34;Initial message post.\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;fischerm\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;chat\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;1708811045.597851\u0026#34; } ], \u0026#34;last_message_timestamp\u0026#34;: \u0026#34;1664771391.765176\u0026#34; } GET /posts/before/\u0026lt;endTime\u0026gt; # Get a list of posts that were posted before the endTime. The endTime slot should be a seconds based timestamp with optional decimal, such as 1664771391.765176.\nRequest HTTP GET /posts/before/1664771391.765176 HTTP/1.1 Host: csc346picturegram.test.apps.uits.arizona.edu curl curl --location --request GET \\ \u0026#39;https://csc346picturegram.test.apps.uits.arizona.edu/posts/before/1664771391.765176\u0026#39; Response 200\n{ \u0026#34;status\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;count\u0026#34;: 3, \u0026#34;messages\u0026#34;: [ { \u0026#34;image_thumbnail_url\u0026#34;: \u0026#34;https://example.com/images/DSC7866-sm.jpg\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Congratulations! If you\u0026#39;re seeing these posts then you\u0026#39;ve probably got your basic app working.\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;fischerm\u0026#34;, \u0026#34;image_description\u0026#34;: \u0026#34;Night time celebration of students in graduation gowns in the forground, with fireworks exploading in the background.\u0026#34;, \u0026#34;image_full_url\u0026#34;: \u0026#34;https://example.com/images/DSC7866.jpg\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;chat\u0026#34; \u0026#34;timestamp\u0026#34;: \u0026#34;1708811130.770543\u0026#34;, }, { \u0026#34;message\u0026#34;: \u0026#34;Another sample post with no image attached.\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;fischerm\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;chat\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;1708811082.482178\u0026#34; }, { \u0026#34;message\u0026#34;: \u0026#34;Initial message post.\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;fischerm\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;chat\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;1708811045.597851\u0026#34; } ], \u0026#34;last_message_timestamp\u0026#34;: \u0026#34;1664771391.765176\u0026#34; } GET /login?service=\u0026lt;serviceURL\u0026gt; # This is not really an API call, as you make this request directly as a browser navigation. This URL should be constructed in such a way that the user clicks on a link to this URL. The API call will result in a 302 redirection to the University's WebAuth system for authentication, and then handle the response, and redirect back to your app.\nThe return URL from this process is the serviceURL passed in as the service query string parameter. Note that the response to this is not a JSON object, it is an HTTP response of text/html with a location header set with the redirection to the Shibboleth Identity Provider. The service URL provided to Shibboleth is a return call to this API and the processlogin action.\nRequest HTTP GET /login?service=http://localhost:8080/ HTTP/1.1 Host: csc346picturegram.test.apps.uits.arizona.edu curl curl --location --request GET \\ \u0026#39;https://csc346picturegram.test.apps.uits.arizona.edu/login?service=http://localhost:8080/\u0026#39; Response 302\nHTTP/1.1 302 date: Thu, 20 Oct 2022 17:44:54 GMT content-type: text/html content-length: 0 location: https://shibboleth.arizona.edu/webauth/login?service=https://csc346picturegram.test.apps.uits.arizona.edu/processlogin/aHR0cDovL2xvY2FsaG9zdDo4MDgwLw GET /processlogin/\u0026lt;serviceToken\u0026gt;?ticket=\u0026lt;CASticket\u0026gt; # This is not really an API call, as you make this request directly as a browser navigation. This URL is only ever called by the user's browser as it is redirected from the Shibboleth Idnetity Provider after the user has logged in. This method takes the serviceToken, decodes the base64 encoded data in it which contains the URL of your application. This is how the API knows where to redirect this response to, along with the CAS ticket. The API call will result in a 302 redirection to the University's WebAuth system for authentication, and then handle the response, and redirect back to your app.\nNote that the response to this is not a JSON object, it is an HTTP response of text/html with a location header set with the redirection to your application, along with the CAS ticket.\nRequest HTTP GET /processlogin/aHR0cDovL2xv?ticket=ST-1666...54638 HTTP/1.1 Host: csc346picturegram.test.apps.uits.arizona.edu curl curl --location --request GET \\ \u0026#39;https://csc346picturegram.test.apps.uits.arizona.edu/processlogin/aHR0cDovL2xv?ticket=ST-1666...54638\u0026#39; Response 302\nHTTP/1.1 302 date: Thu, 20 Oct 2022 17:44:54 GMT content-type: text/html content-length: 0 location: http://localhost:8080/?ticket=ST-166628...mn8idKJW1b8BPdk7 "},{"id":14,"href":"/csc346/docs/examples/http/","title":"Raw HTTP Example","section":"Examples","content":" Raw HTTP Example # In this class I will keep referring to the syntax for executing a \u0026quot;raw\u0026quot; HTTP command over the network. I really want folks to have a good gasp of how this relatively simple protocol works. It forms the basis for nearly all our interactions with servers and API calls.\nHTTP vs HTTPS # Before you can experiment with an HTTP command, you need to connect to a web server of some sort. However the very raw network connections we use to test with generally do not support encryption. They rely on the original plaintext HTTP connections over port 80. Finding valid websites to test against is getting harder, as the vast majority of all sites will force a redirection from http://... to https://... for connection attempts.\nThe wonderful example.com is maintained by iana.org, and is a really great resource for experimenting with HTTP commands, as well as being a \u0026quot;valid\u0026quot; example website and URL for all sorts of uses. Thankfully they still allow \u0026quot;plaintext\u0026quot; HTTP connections, and do not force upgrades to HTTPS for all connection attempts. Additionally, the Computer Science department's lectura server also supports plaintext HTTP connections still (at least as of Spring 2024). That's what we'll use for this demo.\nnetcat # To create a raw TCP socket to a remote server, we'll use the netcat command line program: nc. If this program isn't present on your computer, you can either SSH to lectura and run it from there, or load up a Docker container to install it in, then run it from there.\nnc -v [ip address or hostname] [port] netcat Dockerfile # If you're having trouble running nc somewhere, you can build your own docker image from the following Dockerfile. Create a new directory, and then create a new Dockerfile inside and copy the following into it. This Dockerfile will create an image based off of debian:bookworm with a few extra things installed already. All we need to do is install netcat.\nFROM buildpack-deps:bookworm-curl RUN set -eux; \\ apt-get update; \\ apt-get install -y --no-install-recommends \\ netcat-traditional Build and run it to get a bash shell, then run nc inside the container.\ndocker build csc346:netcat . docker run -it --rm csc346:netcat bash Example # Here is a basic nc based example that requests the webpage from the following URL:\nhttp://www2.cs.arizona.edu/courses/descriptions.html First we need to connect to the host itself, which for this URL is www2.cs.arizona.edu. Since we're doing plaintext HTTP, we will connect on port 80.\nnc -v www2.cs.arizona.edu 80 When we hit enter, we should get a connection response from nc saying we've established a connection. At that point you'll be at a blank line, and any text typed or pasted in here will be sent to the remote host when you hit the enter key.\nIt is at this point that we send our actual HTTP request.\nGET /courses/descriptions.html HTTP/1.1 Host: www2.cs.arizona.edu After typing in those two lines, the critical part is that you have to indicate to the server that you're done with the request, and that the server should process it and send back the response. The HTTP specification states that we do this by sending TWO CRLF sequences. When doing this interactively, this means you have to hit Return twice.\nIn the following animation, you can see that the server doesn't respond until the second Return happens following the Request.\nTimeout # If you don't send that second CRLF sequence, the server will just sit there waiting, and eventually time out.\n"}]